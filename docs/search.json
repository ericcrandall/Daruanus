[
  {
    "objectID": "Daruanus_IBD_migrate.html",
    "href": "Daruanus_IBD_migrate.html",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "",
    "text": "Code\nlibrary(readxl)\nlibrary(adegenet)\nlibrary(gdistance)\nlibrary(pegas)\nlibrary(hierfstat)\nlibrary(raster)\nlibrary(rgdal)\nlibrary(tidyverse)\nlibrary(graph4lg)\nlibrary(coda)\nlibrary(knitr)\nlibrary(forcats)\nlibrary(strataG)\nlibrary(EnvStats)\nlibrary(genepopedit)\nlibrary(perm)\nlibrary(data.table)\n\nsource(\"IBD_functions.R\")"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#read-in-the-data",
    "href": "Daruanus_IBD_migrate.html#read-in-the-data",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "Read in the data",
    "text": "Read in the data\n\n\nCode\n#read in the data\nDaruanus.gen <- read.genepop(\"data/Daruanus_Fauvelot.gen\", ncode = 3L)\n\n\n\n Converting data from a Genepop .gen file to a genind object... \n\n\nFile description:  Dascyllus aruanus all populations 1358 individuals \n\n...done.\n\n\nCode\n# rename the populations to just the text values\nDaruanus.gen@pop <- Daruanus.gen@pop %>% str_extract(\"[A-Za-z]+\") %>% as.factor()\n\n# read in the locality information\nDaruanus.sites <- read_excel(\"data/Daruanus_sites.xlsx\")\n\nDaruanus.gen@pop %>% tibble(pop = as.character(.)) %>% count(pop)"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#test-for-hwe",
    "href": "Daruanus_IBD_migrate.html#test-for-hwe",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "Test for HWE",
    "text": "Test for HWE\nTest for HWE. First look at the number of populations that have HWE departures for each locus. Then look at the distribution of p-values following Waples (2014). A flat distribution is fine, but enrichment for low p-values suggests that the locus is not globally at HWE.\n\nCodeHardy-Weinberg StatsP-Values Plot\n\n\n\nseparated_pops <- seppop(Daruanus.gen)\n\n# perform HWE test\nhw <- map(separated_pops, hw.test)\n \nhw2 <- do.call(rbind,hw) %>% as_tibble(rownames = \"locus\") %>%  \n                group_by(locus) %>%\n        summarize(outofhwe = length(which(Pr.exact < 0.05)), \n             outofhwe_prop = length(which(Pr.exact < 0.05))/length(hw),\n             meanp = mean(Pr.exact))\n\n\n\n\npvalues<- do.call(rbind,hw) %>% as_tibble(rownames = \"locus\") %>%  \n          group_by(locus) %>% \n     ggplot(aes(x=Pr.exact)) + \n                    geom_histogram(bins=10) + \n                    facet_wrap(~locus)\n\n\n\n\nhw2\n\n\n\n  \n\n\n\n\n\n\npvalues\n\n\n\n\n\n\n\nIt’s pretty clear we need to zap loci 408, 494, and 593. 565 is a little weird, but let’s keep it.\n\nDrop Some Loci\n\n\nCode\nlocNames(Daruanus.gen)\n\n\n [1] \"304\" \"408\" \"331\" \"589\" \"494\" \"523\" \"360\" \"565\" \"542\" \"593\" \"590\"\n\n\nCode\nDaruanus.gen <- Daruanus.gen[loc=-c(2,5,10)]\n\n#convert to strataG gtypes\nDaruanus.gtypes <- genind2gtypes(Daruanus.gen)\n\n#genind_to_genepop(Daruanus.gen, output = \"Daruanus/Daruanus_All_8locus.txt\")"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#split-by-archipelago",
    "href": "Daruanus_IBD_migrate.html#split-by-archipelago",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "Split by Archipelago",
    "text": "Split by Archipelago\n\n\nCode\n#split them again\nseparated_pops <- seppop(Daruanus.gen)\n\n#split off the Fiji samples\nfijipops <- Daruanus.sites %>% filter(Region==\"Fiji\")\nDaruanus.Fiji <- repool(separated_pops[fijipops$Abbr])\n\n#split off the NC samples\nNCpops <- Daruanus.sites %>% filter(Region==\"NC\") %>% filter(Abbr!=\"Hie\")\nDaruanus.NC <- repool(separated_pops[NCpops$Abbr])\n\n#split off the FP samples\nFPpops <- Daruanus.sites %>% filter(Region == \"FP\") %>% \n  filter(Abbr %in% c(\"Puna\",\"Tetia\", \"Tem\",\"Mo\",\"Tahaa\"))\nDaruanus.FP <- repool(separated_pops[FPpops$Abbr])\n\n#genind_to_genepop(Daruanus.NC,output = \"Daruanus/NC/Daruanus_NC.txt\")\n#genind_to_genepop(Daruanus.Fiji,output = \"Daruanus/Fiji/Daruanus_Fiji.txt\")\n#genind_to_genepop(Daruanus.FP,output = \"Daruanus/FP/Daruanus_FP.txt\")"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#traditional-isolation-by-distance-method",
    "href": "Daruanus_IBD_migrate.html#traditional-isolation-by-distance-method",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "Traditional Isolation by Distance Method",
    "text": "Traditional Isolation by Distance Method\nBased on the OG (Rousset 1997) estimator from slope of the IBD regression.\n\nCalculate distance matrices\n\nGenetic Distances\nWeir and Cockerham’s Fst and other basic stats\n\n\nCode\nDaruanus.NC.hfst <- genind2hierfstat(Daruanus.NC)\nDaruanus.NC.loci <- genind2loci(Daruanus.NC)\n#gen.loci <- genind2loci(gen)\nstats.NC <- basic.stats(Daruanus.NC)\ntheta.NC <- theta.msat(Daruanus.NC.loci)\n#mean theta\nmean(theta.NC[,2])\n\n\n[1] 156.622\n\n\nCode\nfst.NC <- genet.dist(Daruanus.NC.hfst, method = \"WC84\")\n# mean Fis values\nstats.NC$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n\n  \n\n\n\nCode\nmeanFis <- stats.NC$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE)) %>%\n                summarize(meanFis = rowMeans(.))\n# linearize\nfst.NC <- fst.NC/(1-fst.NC)\n\n\n\n\nGeographic Distances\n\n\nCode\n#calculate great circle distance\ngcdists_NC <- as.dist(pointDistance(NCpops[,5:4], lonlat=T)/1000)\nattr(gcdists_NC, \"Labels\") <- NCpops$Abbr\ngcdists.mat_NC <- as.matrix(gcdists_NC)\n#write.csv(as.matrix(gen.fst), \"Daruanus_linearizedFst.csv\", row.names = F, quote=F)\n#write.csv(as.matrix(gcdists), \"Daruanus_gcdists.csv\", row.names = F, quote=F)\n\n#pull out a few other distances we'll need\nneighbordists_NC <- gcdists.mat_NC[row(gcdists.mat_NC) == col(gcdists.mat_NC) + 1]\ndistfromP1_NC <- gcdists.mat_NC[,1]\nmaxdist_NC <- max(gcdists.mat_NC)\nmeandists_NC <- mean(neighbordists_NC)\n\n\n\n\n\nCalculate linear model\nFirst to get the slope \\(m\\) we need to make a simple linear model. I don’t think significance is really important here, but we can calculate that with a Mantel test.\n\n\nCode\n# mantel test\nmantelt <- mantel.randtest(fst.NC,gcdists_NC, nrepet = 10000)\n\ndistances <- tibble(distance=as.vector(gcdists_NC),fst=as.vector(fst.NC))\n\nlmodel_NC <- lm(fst ~ distance , distances)\n\nslope_NC <- round(lmodel_NC$coefficients[2],7)\nmantelr <- round(mantelt$obs, 2)\npvalue <- round(mantelt$pvalue, 5)\n\nlmodel_plot_NC <- ggplot(distances,aes(x=distance,y=fst)) +\n              geom_point() + \n                          geom_smooth(method=lm) + \n                          xlab(\"Geographic Distance (km)\") + \n             ylab(expression(F[\"ST\"]/1-F[\"ST\"])) + \n             geom_text(label = paste(\"m =\", slope_NC, \n                          \"; Mantel r =\", mantelr,\n                         \", p =\", pvalue ), \n                  mapping = aes(x = 80, y = -0.002))\n\nlmodel_plot_NC\n\n\n\n\n\nCode\n#ggsave(\"NC_IBD.pdf\", plot=clown_plot,device=\"pdf\", width=7, height=5,units=\"in\")\n\n\nYowza. Negative slope! As Cecile had already measured. But the Fst values are really teeny, and there’s a lot of error in their measurement.\n\n\nCalculate Effective Size\nTake the harmonic mean of the Ne across all pops\n\nNe_estimates_NC <- Ne_estimates_f %>% filter(Population %in% NCpops$Abbr)\n\n#write_csv(Nb_estimates_f,\"NeEstimator/Nb_estimates_recruits_NeTable.csv\")\nNe_estimates_NC[,c(1:4,8,11,12)]\n\n\n\n  \n\n\n# harmonic mean of Nb, following Waples and Do 2010\nNe_hm_NC <- harm_mean(Ne_estimates_NC$Ne)\n\n\n\nNe vs. Sampling Window\nLet’s cluster the sites by UPGMA\n\nplot(hclust(gcdists_NC,\"average\"))\n\n\n\n\nLet’s explore Ne and \\(F_{is}\\) when lumping populations… Lump populations that are 10, 20, 40, 100 and 200 km apart.\n\n10km20km40km100km200km (all pops as one)Figure\n\n\n\nstats.NC$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\nDaruanus.NC.10km <- Daruanus.NC\n\nDaruanus.NC.10km@pop <-  Daruanus.NC.10km@pop %>% \n    fct_collapse(\n   center = c(\"Go\",\"Lar\")\n        )\n\nDaruanus.NC.10km.stats <- basic.stats(Daruanus.NC.10km)\n\nDaruanus.NC.10km.stats$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\nmeanFis_NC_10km <- Daruanus.NC.10km.stats$Fis %>% as_tibble() %>%\n                    summarize(across(everything(),mean, na.rm=TRUE)) %>% \n                  summarize(meanFis = rowMeans(.))\n\n#genind_to_genepop(Daruanus.NC.10km,output = \"Daruanus/NC/Daruanus_NC_10km.txt\")\n\nNe_estimates_NC10km <- read_NeEstimator(\"NeEstimator/Daruanus_LDNe_NC_10kmxLD.txt\")\nNe_estimates_NC10km <- WDFilter(Ne_estimates_NC10km, 10)\n\n\nNe_hm_NC10km <- harm_mean(Ne_estimates_NC10km$Ne)\n\nNe_hm_NC10km\n\n[1] 638.502\n\n\n\n\n\nDaruanus.NC.20km <- Daruanus.NC\n\nDaruanus.NC.20km@pop <-  Daruanus.NC.20km@pop %>% fct_collapse(\n   center = c(\"MBO\",\"Lar\",\"Go\",\"QBW\") )\n\nDaruanus.NC.20km.stats <- basic.stats(Daruanus.NC.20km)\n\nDaruanus.NC.20km.stats$Fis %>% as_tibble() %>% \n              summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\nmeanFis_NC_20km <- Daruanus.NC.20km.stats$Fis %>% as_tibble() %>%\n                  summarize(across(everything(),mean, na.rm=TRUE)) %>% \n                    summarize(meanFis = rowMeans(.))\n\n#genind_to_genepop(Daruanus.NC.20km,output = \"NC/Daruanus_NC_20km.txt\")\n\nNe_estimates_NC20km <- read_NeEstimator(file = \"NeEstimator/Daruanus_LDNe_NC_20kmxLD.txt\")\nNe_estimates_NC20km <- WDFilter(Ne_estimates_NC20km, 10)\n\nNe_hm_NC20km <- harm_mean(Ne_estimates_NC20km$Ne)\n\nNe_hm_NC20km\n\n[1] 3062.967\n\n\n\n\n\nDaruanus.NC.40km <- Daruanus.NC\n\nDaruanus.NC.40km@pop <-  Daruanus.NC.40km@pop %>% fct_collapse(\n   north = c(\"Mara\",\"Ten\"),\n   center = c(\"MBO\",\"Lar\",\"Go\",\"QBW\") )\n\nDaruanus.NC.40km.stats <- basic.stats(Daruanus.NC.40km)\n\nDaruanus.NC.40km.stats$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\nmeanFis_NC_40km <- Daruanus.NC.40km.stats$Fis %>% as_tibble() %>%\n  summarize(across(everything(),mean, na.rm=TRUE)) %>% summarize(meanFis = rowMeans(.))\n\n#genind_to_genepop(Daruanus.NC.40km,output = \"NC/Daruanus_NC_40km.txt\")\n\nNe_estimates_NC40km <- read_NeEstimator(file = \"NeEstimator/Daruanus_LDNe_NC_40kmxLD.txt\")\nNe_estimates_NC40km <- WDFilter(Ne_estimates_NC40km, 10)\n\nNe_hm_NC40km <- harm_mean(Ne_estimates_NC40km$Ne)\n\n\nNe_hm_NC40km\n\n[1] 2373.392\n\n\n\n\n\nDaruanus.NC.100km <- Daruanus.NC\n\nDaruanus.NC.100km@pop <-  Daruanus.NC.100km@pop %>% fct_collapse(\n  north = c(\"Mara\"),\n  east = c(\"MBO\",\"Lar\",\"Go\",\"QBW\",\"Tote\",\"Ten\") )\n\nDaruanus.NC.100km.stats <- basic.stats(Daruanus.NC.100km)\n\nDaruanus.NC.100km.stats$Fis %>% as_tibble() %>% \n                    summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\nmeanFis_NC_100km <- Daruanus.NC.100km.stats$Fis %>% as_tibble() %>%\n  summarize(across(everything(),mean, na.rm=TRUE)) %>% \n    summarize(meanFis = rowMeans(.))\n\n\n\n#genind_to_genepop(Daruanus.NC.100km,output = \"NC/Daruanus_NC_100km.txt\")\n\nNe_estimates_NC100km <- read_NeEstimator(file =\n                                           \"NeEstimator/Daruanus_LDNe_NC_100kmxLD.txt\")\nNe_estimates_NC100km <- WDFilter(Ne_estimates_NC100km, 10)\n\n#replace one very large estimate of Ne with 20,0000\nNe_estimates_NC100km$Ne[1] <- 20000\n\nNe_hm_NC100km <- harm_mean(Ne_estimates_NC100km$Ne)\n\n\nNe_hm_NC100km\n\n[1] 12268.54\n\n\n\n\n\nNe_estimates_NC200km <- read_NeEstimator(file =\n                                    \"NeEstimator/Daruanus_LDNe_NC_1popxLD.txt\")\nNe_estimates_NC200km <- WDFilter(Ne_estimates_NC200km, 10)\n\n\n\nNe_hm_NC200km <- Ne_estimates_NC200km$Ne\nNe_all_NC <- Ne_estimates_NC200km$Ne\n\nNe_all_NC_CI <- c(Ne_estimates_NC200km$ParametricLow,\n                  Ne_estimates_NC200km$ParametricHigh)\n\nNe_all_NC\n\n[1] 6294.9\n\n\n\n\n\nNCwindows <- tibble(SampleWindow = c(0,10,20,40,100,200),\n             hm_Ne = c(Ne_hm_NC,Ne_hm_NC10km,Ne_hm_NC20km,Ne_hm_NC40km,\n                                Ne_hm_NC100km,Ne_hm_NC200km))\n\nggplot(NCwindows, aes(x = SampleWindow, y = hm_Ne)) + geom_point() + geom_line() +\n  ylim(0,20000) + xlim(0,300)\n\n\n\n#ggsave(\"NC_Ne_v_SampDistance.pdf\",height = 7, width = 7)\n\n\n\n\n\n\nCalculate Effective Density\n\n# Divide by mean distance between sampling sites to get density\nDe_NC <- Ne_hm_NC/meandists_NC\nDe_all_NC <- Ne_all_NC / maxdist_NC\n\nMean density is 32.6102505 individuals/km, or if we do the whole sample as a single population 41.9068643 individuals/km"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#migraine-method",
    "href": "Daruanus_IBD_migrate.html#migraine-method",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "MigraiNe Method",
    "text": "MigraiNe Method\n\nRunning MigraiNe\nI modified the genepop file by adding sampling coordinates as the name of the last individual in each population. These coordinates were distances in km along a the mostly linear SW coastline of New Caledonia, which runs a total of ~612km. It is ~418km to the first population at Mara, so I am adding that value to the coordinates in the file.\n\ndistfromP1_NC+418\n\n    Mara      Ten      MBO      Lar       Go      QBW     Tote \n418.0000 454.7026 494.1474 507.2045 514.9837 527.4177 568.2117 \n\n\n\nFirst RunSecond RunThird RunFourth RunSeventh Run\n\n\n\nGenepopFileName=../Daruanus_NC.txt\nDemographicModel=LinearIBD\n# I modified the genepop file by adding sampling coordinates as the name of the \n# last individual in each population. These coordinates were distances in km along \n# a the mostly linear SW coastline of New Caledonia, \n# which runs a total of ~612km. It is ~418km to the first population at Mara, \n# so I am adding that value to the coordinates in the file.\nPSONMax=612 0\n#Neighborhood size is based on mean distance between populations = 25.08\n#612/25.08 = 24.40 so I will use 25 bins\nGeoBinNbr=25\nGeoUnit= ind.km\n#alternate way of specifying the habitat, not used for now\n#habitatPars= 0.5 0.5 400 1 0\n#habitatPars=0 0 0 300 0\n#Mutation Model is K-allele = PIM, with k=2 for SNPs. GivenK is number of alleles\n# at each locus\nMutationModel=PIM\nGivenK=26,35,11,57,47,32,30,23,57,34,44\nsamplingSpace=,,\nsamplingScale=,,\n#Analysis - this will do 5 runs of 100 points and\n#overwrite those with 10 runs of 250 points\nwriteSequence= Over,Over,Over,Over,Over,Append,10\nStatisticSequence=PAC\nPointNumber=100,100,100,100,100,250\nNrunsperpoint=30,30,30,30,30,50\n#Wide priors on Neu, Nem and g\nLowerBound=0.1,1,0\nUpperbound=1,2500,1\noneDimCI= 2Nmu, 2Nm, Nb, condS2\nCoreNbrForR=4\n#Plots= all1DProfiles\n1DProfiles=2Nmu, 2Nm, Nb, condS2, g\nextrascale=Nb=logscale\ngraphicFormat=pdf\n#writeAdHocFiles=T\n\n\n\n\nGenepopFileName=../Daruanus_NC.txt\nDemographicModel=LinearIBD\n# I modified the genepop file by adding sampling coordinates as the name of the \n# last individual in each population. These coordinates were distances in km along \n# a the mostly linear SW coastline of New Caledonia, \n# which runs a total of ~612km. It is ~418km to the first population at Mara, \n# so I am adding that value to the coordinates in the file.\nPSONMin=0 0\nPSONMax=612 0\n#Neighborhood size is based on mean distance between populations = 25.08\n#612/25.08 = 24.40 so I will use 26 bins\nGeoBinNbr=26\nGeoUnit= ind.km\n#alternate way of specifying the habitat, not used for now\n#habitatPars= 0.5 0.5 400 1 0\n#habitatPars=0 0 0 300 0\n#Mutation Model is K-allele = PIM, with k=2 for SNPs\nMutationModel=PIM\nGivenK=26,35,11,57,47,32,30,23,57,34,44\nsamplingSpace=,,\nsamplingScale=,,\n#Analysis - this will do 5 runs of 100 points and\n#overwrite those with 10 runs of 250 points\nwriteSequence= Over,Over,Over,Over,Over,Append,10\nStatisticSequence=PAC\nPointNumber=100,100,100,100,100,250\nNrunsperpoint=30,30,30,30,30,50\n#Wide priors on Neu, Nem and g\nLowerBound=0.1,1,0\nUpperbound=2,10000,1\noneDimCI= 2Nmu, 2Nm, Nb, condS2\nCoreNbrForR=4\n#Plots= all1DProfiles\n1DProfiles=2Nmu, 2Nm, Nb, condS2, g\nextrascale=Nb=logscale\ngraphicFormat=pdf\n#writeAdHocFiles=T\n\nThis finished in 250 minutes, and had very similar results to the first run\n\n\nAfter removing 3 loci\n\nGenepopFileName=../../Daruanus_NC.txt\nDemographicModel=LinearIBD\n# I modified the genepop file by adding sampling coordinates as the name of the \n# last individual in each population. These coordinates were distances in km along \n# a the mostly linear SW coastline of New Caledonia, \n# which runs a total of ~612km. It is ~418km to the first population at Mara, \n# so I am adding that value to the coordinates in the file.\nPSONMin=0 0\nPSONMax=612 0\n#Neighborhood size is based on mean distance between populations = 25.08\n#612/25.08 = 24.40 so I will use 25 bins\nGeoBinNbr=25\nGeoUnit= ind.km\n#alternate way of specifying the habitat, not used for now\n#habitatPars= 0.5 0.5 400 1 0\n#habitatPars=0 0 0 300 0\n#Mutation Model is K-allele = PIM, with k=2 for SNPs\nMutationModel=PIM\nGivenK=26,11,57,32,30,23,57,44\nsamplingSpace=,,\nsamplingScale=,,\n#Analysis - this will do 5 runs of 100 points and\n#overwrite those with 10 runs of 250 points\nwriteSequence= Over,Over,Over,Over,Over,Append,10\nStatisticSequence=PAC\nPointNumber=100,100,100,100,100,250\nNrunsperpoint=30,30,30,30,30,50\n#Wide priors on Neu, Nem and g\nLowerBound=0.1,1,0\nUpperbound=2,10000,1\noneDimCI= 2Nmu, 2Nm, Nb, condS2\nCoreNbrForR=4\nPlots= all1DProfiles\n#1DProfiles=2Nmu, 2Nm, Nb, condS2, g\nextrascale=Nb=logscale\ngraphicFormat=pdf\n#writeAdHocFiles=T\n\n\n\nAnd, lo, I forgot to use the condS2 parameterization that is recommended for weak IBD signals by Leblois and Rousset (2020)!\n\nGenepopFileName=../../Daruanus_NC.txt\nDemographicModel=LinearIBD\n# I modified the genepop file by adding sampling coordinates as the name of the \n# last individual in each population. These coordinates were distances in km along \n# a the mostly linear SW coastline of New Caledonia, \n# which runs a total of ~612km. It is ~418km to the first population at Mara, \n# so I am adding that value to the coordinates in the file.\nPSONMin=0 0\nPSONMax=612 0\n#Neighborhood size is based on mean distance between populations = 25.08\n#612/25.08 = 24.40 so I will use 25 bins\nGeoBinNbr=25\nGeoUnit= ind.km\n#alternate way of specifying the habitat, not used for now\n#habitatPars= 0.5 0.5 400 1 0\n#habitatPars=0 0 0 300 0\n#Mutation Model is K-allele = PIM, with k=2 for SNPs\nMutationModel=PIM\nGivenK=26,11,57,32,30,23,57,44\n#sampling - this performs uniform sampling of ln(sigma^2), which is the quantity we are interested in\nsamplingSpace=,,condS2\nsamplingScale=,,logscale\n#Analysis - this will do 5 runs of 100 points and\n#overwrite those with 10 runs of 250 points\nwriteSequence= Over,Over,Over,Over,Over,Append,10\nStatisticSequence=PAC\nPointNumber=100,100,100,100,100,250\nNrunsperpoint=30,30,30,30,30,50\n#Wide priors on Neu, Nem and g\nLowerBound=0.1,1,1\nUpperbound=2,10000,100000\noneDimCI= 2Nmu, 2Nm, Nb, condS2\nCoreNbrForR=4\nPlots= all1DProfiles\n#1DProfiles=2Nmu, 2Nm, Nb, condS2, g\nextrascale=Nb=logscale\ngraphicFormat=pdf\n#writeAdHocFiles=T\n\nFinishing in 171.6 minutes\n\n\nBrought in the priors a little. Didn’t change the results much.\n\nGenepopFileName=../../Daruanus_NC.txt\nDemographicModel=LinearIBD\n# I modified the genepop file by adding sampling coordinates as the name of the \n# last individual in each population. These coordinates were distances in km along \n# a the mostly linear SW coastline of New Caledonia, \n# which runs a total of ~612km. It is ~418km to the first population at Mara, \n# so I am adding that value to the coordinates in the file.\nPSONMin=0 0\nPSONMax=612 0\n#Neighborhood size is based on mean distance between populations = 25.08\n#612/25.08 = 24.40 so I will use 26 bins\nGeoBinNbr=26\nGeoUnit= ind.km\n#alternate way of specifying the habitat, not used for now\n#habitatPars= 0.5 0.5 400 1 0\n#habitatPars=0 0 0 300 0\n#Mutation Model is K-allele = PIM, with k=2 for SNPs\nMutationModel=PIM\nGivenK=26,11,57,32,30,23,57,44\n#sampling - this performs uniform sampling of ln(sigma^2)\nsamplingSpace=,,condS2\nsamplingScale=,,logscale\n#Analysis - this will do 5 runs of 100 points and\n#overwrite those with 10 runs of 250 points\nwriteSequence= Over,Over,Over,Over,Over,Append,10\nStatisticSequence=PAC\nPointNumber=100,100,100,100,100,250\nNrunsperpoint=30,30,30,30,30,50\n#Wide priors on Neu, Nem and conds2\nLowerBound=0.1,1,1\nUpperbound=2,6000,10000\noneDimCI= 2Nmu, 2Nm, Nb, condS2, g\n#oneDimCI= All\nCoreNbrForR=4\nPlots= all1DProfiles\n#1DProfiles=2Nmu, 2Nm, Nb, condS2, g\nextrascale=Nb=logscale\ngraphicFormat=pdf\nwriteAdHocFiles=T\n\nFinished in 187.55 minutes.\n\n\n\n\n\nCreate Dispersal Kernels\n\nSigma estimates\nSo we have two routes to estimate \\(\\sigma\\) here.\n\n\nFrom Neighborhood Size\n\\[\n\\sigma = \\sqrt\\frac{NS}{4D_e}\n\\]\n\n\nFrom Sigma^2\nAfter converting it from lattice units to km\n\\[\n\\sigma = \\sqrt{\\sigma^2}\n\\]\nThis got me the following estimates.\nOutput from run 7.\n\n\nCode\nrunDir <- \"./NC/Migraine/run7\"\n#runDir <- \"/Users/edc5240/github/IBD_Kernels/Daruanus/NC/Migraine/run7\"\nresult <- read_migraine(runDir)\nNS_NC <- result[\"NS\"]\nNSCI_NC <- c(result[\"NSCI1\"],result[\"NSCI2\"])\nNmu_NC <- result[\"Nmu\"]\nNm_NC <- result[\"Nm\"]\ng_NC <- result[\"g\"]\nlattice2geog_NC <- result[\"lattice2geog\"]\n\nsigma2_NC <- g_to_sigma2(g_NC)\nsigma_fromsigma2_NC <- sqrt(sigma2_NC*lattice2geog_NC)\nsigma_fromNS_NC <- sqrt(NS_NC/(4*De_NC))\nsigmaCI_fromNS_NC <- sqrt(NSCI_NC/(4*De_NC))\n\nsigma_fromNS_all_NC <- sqrt(NS_NC/(4*De_all_NC))\nsigmaCI_fromNS_all_NC <- sqrt(NSCI_NC/(4*De_all_NC))\n\n\nThe \\(\\sigma\\) we get from Neighborhood Size \\(\\sigma\\) is 227. We get a much lower estimate from \\(\\sigma^2\\), with \\(\\sigma\\) = 1750\n\n\n\nConfidence Intervals\nPropagating error sorta following Pinsky et al. table S2\n\nError in Effective Size\nFollowing Pinsky, Montes, and Palumbi (2010) I am going to bootstrap across the confidence intervals for each Nb estimate. Unfortunately, the new jackknife method of Jones, Ovenden, and Wang (2016) often results in infinite upper bounds with marine data (but then, so does the parametric method). I’m also going to use a uniform distribution for the error because approximating the error structure with ChiSq or Normal distributions is not a simple task and I’m just trying to get a sketch of the error to compare with MigraiNe anyway. I’m going to set “Infinite” values in the upper CI to 20,000 since I rarely see upper bounds that high.\n\nFor Harmonic Mean MethodFor Whole Sample Method\n\n\n\n\nCode\nNe_estimates_NC$JackknifeHigh[which(is.na(Ne_estimates_NC$JackknifeHigh))] <- 20000\nNe_estimates_NC$JackknifeHigh <- as.numeric(Ne_estimates_NC$JackknifeHigh)\nNe_estimates_NC$JackknifeLow <- as.numeric(Ne_estimates_NC$JackknifeLow)\n\n# couldn't get purrr:map to do this, so resorted to mapply to set upper and lower bounds\nNe_error_NC <- NULL\nfor(n in 1:100000){\n  hm <- harm_mean(mapply(runif, n=1, \n                   min=Ne_estimates_NC$JackknifeLow,\n                   max=Ne_estimates_NC$JackknifeHigh))\n  Ne_error_NC <- c(Ne_error_NC,hm)\n}\nnames(Ne_error_NC)<-NULL\n#write.csv(Ne_error_NC, \"NC/Ne_error_NC.csv\",quote=F,row.names = F)\nggplot(data = tibble(Ne_error_NC), aes(x=Ne_error_NC)) + geom_density()\n\n\n\n\n\n\n\nNaaykens and D’Aloia (2022) showed that using the whole sample to estimate density gives pretty similar results to the harmonic mean method, so I’m also going to try that.\n\n\nCode\nNbl95 <- Ne_all_NC_CI[1]\nNbu95 <- Ne_all_NC_CI[2]\nNb <- Ne_all_NC\nr2_NC <- Ne_estimates_NC200km$r2\ner2_NC <- 1/Ne_estimates_NC200km$SampSize + 3.19/Ne_estimates_NC200km$SampSize ^2 #from Waples 2006 table 2\ndf_NC <- Ne_estimates_NC200km$IndAlleles\n\n\nWaplesMonoNe(r2p(r2_NC,er2_NC))\n\n\n[1] 6140.55\n\n\nCode\n# this shows that we can get approximately what NeEstimator gives us... not sure why its not exact... must be missing some correction\nrCI_NC <- df_NC*r2_NC / (qchisq(c(0.025,0.975), df = df_NC))\nWaplesMonoNe(rCI_NC - er2_NC)\n\n\n[1]  3729.688 16288.111\n\n\nCode\n#and now to get and plot the error distribution\nNe_error_all_NC <- WaplesMonoNe(((df_NC*r2_NC)/(rchisq(10000, df = df_NC))) - er2_NC)\n\nggplot(data = tibble(Ne_error_all_NC), aes(x=Ne_error_all_NC)) + geom_density() + xlim(0,20000)\n\n\n\n\n\n\n\n\n\n\nError in Effective Density\nOne issue with this analysis is that, while Neel et al. (2013) make a good case that we are estimating the Ne of the local neighborhood, we don’t actually know what the size of the neighborhood is. Indeed, that’s actually what we are trying to estimate. (Pinsky, Montes, and Palumbi 2010) used neighborhoods that were 1/2 the distance to the next neighborhood on either side of the sampling site, while (Pinsky et al. 2017) didn’t even attempt this and just used the Ne of the whole sampled population, and divided by the length of the whole sampled area.\nThis is another area of uncertainty, so we should model the uncertainty in neighborhood length. We know its between 10 and 40 km based on the Ne vs. Sampling Window analysis above…\n\n\nCode\nNe_error_NC <- read_csv(file = \"NC/Ne_error_NC.csv\")$x %>% as.vector\nDe_error_NC <- Ne_error_NC/ rnorm(100000,mean=meandists_NC,sd = 15/1.96)\n\nDe_error_all_NC <- Ne_error_all_NC / maxdist_NC\n\nggplot(data = tibble(De_error_all_NC), aes(x=De_error_all_NC)) + geom_density() + xlim(0,250)\n\n\n\n\n\nCode\nggplot(data = tibble(De_error_NC), aes(x=De_error_NC)) + geom_density() + xlim(0,250)\n\n\n\n\n\n\n\nError in Neighborhood Size\nUsing a uniform distribution is out because there is clearly a peaked distribution in the Migraine output. So I am using a quick fit to a truncated lognormal distribution.\n\n\n\nMigraine_Run2_Neighborhood_Theta\n\n\n\n\nCode\nNSCI_NC\n\n\n     NSCI1      NSCI2 \n9.8516e+04 1.0000e+12 \n\n\nCode\ncurve(dlnorm(x, meanlog = log(NS_NC), sdlog = log(2.75e5)))\n\n\n\n\n\nCode\nqlnorm(c(0.025,0.975),meanlog = log(NS_NC), sdlog = log(2.75e5))\n\n\n[1] 1.464785e-04 3.073026e+17\n\n\n\n\nCode\nNeighborhood_error_NC <- rlnormTrunc(n = 100000, meanlog = log(NS_NC), \n                                     sdlog = log(2.75e5), min = NSCI_NC[1], max = NSCI_NC[2])\n\nggplot(data = tibble(Neighborhood_error_NC), aes(x=Neighborhood_error_NC)) + \n  geom_density() + scale_x_log10()\n\n\n\n\n\nCode\nsigma_error_fromNS_NC <- sqrt(Neighborhood_error_NC/(4*De_error_NC))\nnames(sigma_error_fromNS_NC) <- NULL\n\nsigma_error_fromNS_all_NC <- sqrt(Neighborhood_error_NC/(4*De_error_all_NC))\nnames(sigma_error_fromNS_all_NC) <- NULL\n\nggplot(data = tibble(sigma_error_fromNS_NC), \n       aes(x=sigma_error_fromNS_NC)) +\n  geom_density() + scale_x_log10()\n\n\n\n\n\nCode\nggplot(data = tibble(sigma_error_fromNS_all_NC), \n       aes(x=sigma_error_fromNS_all_NC)) +\n  geom_density() + scale_x_log10()\n\n\n\n\n\nCode\nquantile(sigma_error_fromNS_NC, c(0.025, 0.975),na.rm=T)\n\n\n       2.5%       97.5% \n   25.80886 56043.57610 \n\n\n\n\nPlot Dispersal Kernels\n\n\nCode\nkernelplot_NC <- ggplot(data.frame(x=c(0,500)),aes(x)) + \n  map(.x = sample(sigma_error_fromNS_NC,1000), .f = function(sigma){\n                         stat_function(fun = dexp, \n                         args = list(rate = 1/sigma),\n                         colour = \"lightblue\",                                  linetype=1,linewidth=0.1,alpha = 0.2) }) +\n  stat_function(fun=dexp,args=list(rate = 1/sigma_fromsigma2_NC), linetype=2,\n             aes(color=\"Migraine_Sigma2\"), show.legend = T) +\n  stat_function(fun=dexp,args=list(rate = 1/sigma_fromNS_NC), linetype=2,\n          aes(color=\"Migraine_Neighborhood_Size\"), show.legend = T) +\n  stat_function(fun=dexp,args=list(rate = 1/sigma_fromNS_all_NC), linetype=2,\n       aes(color=\"Migraine_Neighborhood_Size_OnePop\"), show.legend = T) +\n  xlab(\"Alongshore Distance (km)\") + \n    ylab(\"Dispersal probability density\") +\n  scale_color_manual(\"Kernel\",values = \n           c(Migraine_Sigma2=\"darkblue\", \n             Migraine_Neighborhood_Size =\"blue\",\n             Migraine_Neighborhood_Size_OnePop = \"darkcyan\")) + \n                        ylim(0,0.01) \n\nkernelplot_NC"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#traditional-isolation-by-distance-method-1",
    "href": "Daruanus_IBD_migrate.html#traditional-isolation-by-distance-method-1",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "Traditional Isolation by Distance Method",
    "text": "Traditional Isolation by Distance Method\nBased on the OG (Rousset 1997) estimator from slope of the IBD regression.\n\nCalculate distance matrices\n\nGenetic Distances\nWeir and Cockerham’s Fst and other basic stats.\n\n\nCode\nDaruanus.Fiji.hfst <- genind2hierfstat(Daruanus.Fiji)\nDaruanus.Fiji.loci <- genind2loci(Daruanus.Fiji)\n#gen.loci <- genind2loci(gen)\nstats.Fiji <- basic.stats(Daruanus.Fiji)\ntheta.Fiji <- theta.msat(Daruanus.Fiji.loci)\n#mean theta\nmean(theta.Fiji[,2])\n\n\n[1] 61.06467\n\n\nCode\nfst.Fiji <- genet.dist(Daruanus.Fiji.hfst, method = \"WC84\")\n# mean Fis values\nstats.Fiji$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n\n  \n\n\n\nCode\n# linearize\nfst.Fiji <- fst.Fiji/(1-fst.Fiji)\n\n\n\nGeographic Distances\nAlso, given the circular nature of Viti Levu, the Euclidean distances measured with pointDistance() are going to be short. So I measured distances between each neighboring locality along the reef in Google Earth, as given in fijidistances\nThis code creates a kml file for import into Google Earth.\n\n\nCode\nfijipops.sp<-fijipops[c(1,2,3,5,4)]\ncoordinates(fijipops.sp) <- c(\"decimalLongitude\",\"decimalLatitude\")\nproj4string(fijipops.sp) <- CRS(\"+proj=longlat +datum=WGS84\")\n#writeOGR(fijipops.sp, dsn=\"Fiji/fijipops.kml\", layer = \"Daruanus samples\", driver = \"KML\")\n\n\nI used these points to measure distances in Google Earth. The total sampled length from Ovalu in the east to the Yasawas in the northwest was a total of ~414km.\n\n\nCode\n#calculate great circle distance\ngcdists_Fiji <- as.dist(pointDistance(fijipops.sp, lonlat=T)/1000)\nattr(gcdists_Fiji, \"Labels\") <- fijipops$Abbr\ngcdists.mat_Fiji <- as.matrix(gcdists_Fiji)\n#write.csv(as.matrix(gen.fst_Fiji), \"Daruanus_linearizedFst.csv\", row.names = F, quote=F)\n#write.csv(as.matrix(gcdists_Fiji), \"Daruanus_gcdists.csv\", row.names = F, quote=F)\n\n#pull out a few other distances we'll need\nneighbordists_Fiji <- gcdists.mat_Fiji[row(gcdists.mat_Fiji) == col(gcdists.mat_Fiji) + 1]\n#distfromP1 <- gcdists.mat[,1]\n\n#meandists <- mean(neighbordists)\nfijidistances <- c((106.03-98.16), (155.22-106.03), (188.58-155.22), (273.50-188.58),\n                   (370-273.50), (378.13-370.0))\n\nmeandists_Fiji <- mean(fijidistances)\nmaxdist_Fiji <- 378.13-98.16\n\nfijidistances\n\n\n[1]  7.87 49.19 33.36 84.92 96.50  8.13\n\n\nThis gives us a mean sampling distance of 46.6616667\n\n\n\n\nCalculate linear model\n\n\nCode\n# mantel test\nmantelt<-mantel.randtest(fst.Fiji,gcdists_Fiji, nrepet = 10000)\n\ndistances <- tibble(distance=as.vector(gcdists_Fiji),fst=as.vector(fst.Fiji))\n\nlmodel_Fiji <- lm(fst ~ distance , distances)\n\nslope_Fiji <- lmodel_Fiji$coefficients[2]\nmantelr <- round(mantelt$obs, 2)\npvalue <- round(mantelt$pvalue, 5)\n\nlmodel_plot_Fiji <- ggplot(distances,aes(x=distance,y=fst)) +\n                geom_point() + geom_smooth(method=lm) + \n                                xlab(\"Geographic Distance (km)\") + \n                ylab(expression(F[\"ST\"]/1-F[\"ST\"])) + \n                geom_text(label = paste(\"m =\", round(slope_Fiji,8),\n                            \"; Mantel r =\", mantelr,\n                            \", p =\", pvalue ), \n                        mapping = aes(x = 80, y = -0.002))\n\nlmodel_plot_Fiji\n\n\n\n\n\nCode\n#ggsave(\"Fiji_IBD.pdf\", plot=lmodel_plot,device=\"pdf\", width=7, height=5,units=\"in\")\n\n\nAnd after removing the 3 wonky loci, the slope is very slightly positive!\n\n\nCalculate Effective Size\nPull out just the relevant Fiji estimates of Ne. The negative numbers reflect very high values of Ne!\n\n\nCode\nNe_estimates_Fiji <- Ne_estimates_f %>% filter(Population %in% fijipops$Abbr)\n\n#\nNe_estimates_Fiji[,c(1:4,8,11,12)]\n\n\n\n\n  \n\n\n\nCode\n# harmonic mean of Ne, following Waples and Do 2010\nNe_hm_Fiji <- harm_mean(Ne_estimates_Fiji$Ne)\n\n\n\n\nNe vs. Sampling Window\nLet’s cluster the sites by UPGMA (using Euclidean distances)\n\nplot(hclust(gcdists_Fiji,\"average\"))\n\n\n\n\n\n10km40km100km300km (all pops as one)Figure\n\n\nLet’s explore Ne and \\(F_{is}\\) when lumping populations… First lump populations that are less than 10 km apart\n\nstats.Fiji$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\nDaruanus.Fiji.10km <- Daruanus.Fiji\n\nDaruanus.Fiji.10km@pop <-  Daruanus.Fiji.10km@pop %>% fct_collapse(\n   east = c(\"Suva\",\"Muaiv\"),\n   west = c(\"Mata\",\"Tave\")\n )\n\nDaruanus.Fiji.10km.stats <- basic.stats(Daruanus.Fiji.10km)\n\nDaruanus.Fiji.10km.stats$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\n#genind_to_genepop(Daruanus.Fiji.10km,output = \"Daruanus/Fiji/Daruanus_Fiji_10km.txt\")\n\nNe_estimates_Fiji10km <- read_NeEstimator(\n                        \"NeEstimator/Daruanus_LDNe_Fiji_10kmxLD.txt\")\nNe_estimates_Fiji10km <- WDFilter(Ne_estimates_Fiji10km, 10)\n\n\nNe_hm_Fiji10km <- harm_mean(Ne_estimates_Fiji10km$Ne)\nNe_hm_Fiji10km\n\n[1] 6700.065\n\n\n\n\n\nDaruanus.Fiji.40km <- Daruanus.Fiji\n\nDaruanus.Fiji.40km@pop <-  Daruanus.Fiji.10km@pop %>% fct_collapse(\n   east = c(\"Suva\",\"Muaiv\"),\n   center = c(\"Yanu\",\"Taga\"),\n   west = c(\"Mata\",\"Tave\")\n )\n\nDaruanus.Fiji.40km.stats <- basic.stats(Daruanus.Fiji.40km)\n\nDaruanus.Fiji.40km.stats$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\n#genind_to_genepop(Daruanus.Fiji.40km,output = \"Daruanus/Fiji/Daruanus_Fiji_40km.txt\")\n\nNe_estimates_Fiji40km <- read_NeEstimator(file = \"NeEstimator/Daruanus_LDNe_Fiji_40kmxLD.txt\")\nNe_estimates_Fiji40km <- WDFilter(Ne_estimates_Fiji40km, 10)\n\nNe_hm_Fiji40km <- harm_mean(Ne_estimates_Fiji40km$Ne)\n\nNe_hm_Fiji40km\n\n[1] 4601.126\n\n\n\n\n\nDaruanus.Fiji.100km <- Daruanus.Fiji\n\nDaruanus.Fiji.100km@pop <-  Daruanus.Fiji.100km@pop %>% fct_collapse(\n   east = c(\"Suva\",\"Muaiv\",\"Yanu\",\"Taga\"),\n   west = c(\"Mata\",\"Tave\",\"Nadi\")\n )\n\nDaruanus.Fiji.100km.stats <- basic.stats(Daruanus.Fiji.100km)\n\nDaruanus.Fiji.100km.stats$Fis %>% as_tibble() %>% summarize(across(everything(),\n                                                                   mean, \n                                                                   na.rm=TRUE))\n\n\n\n  \n\n\n#genind_to_genepop(Daruanus.Fiji.100km,output = \"Fiji/Daruanus_Fiji_100km.txt\")\n\nNe_estimates_Fiji100km <- read_NeEstimator(file =\n                                             \"NeEstimator/Daruanus_LDNe_Fiji_100kmxLD.txt\")\nNe_estimates_Fiji100km <- WDFilter(Ne_estimates_Fiji100km, 10)\n\nNe_hm_Fiji100km <- harm_mean(Ne_estimates_Fiji100km$Ne)\n\nNe_hm_Fiji100km\n\n[1] 5822.584\n\n\n\n\n\nNe_estimates_Fiji300km <- read_NeEstimator(file =\n                                             \"NeEstimator/Daruanus_LDNe_Fiji_1popxLD.txt\")\nNe_estimates_Fiji300km <- WDFilter(Ne_estimates_Fiji300km, 10)\n\n\n\nNe_hm_Fiji300km <- 20000\nNe_all_Fiji <- Ne_estimates_Fiji300km$Ne\n\nNe_all_Fiji_CI <- c(Ne_estimates_Fiji300km$ParametricLow,\n                    Ne_estimates_Fiji300km$ParametricHigh)\n\nNe_all_Fiji\n\n[1] -207211.8\n\nNe_all_Fiji_CI\n\n[1] 6613.9     NA\n\n\n\n\n\nfijiwindows <- tibble(SampleWindow = c(0,10,40,100,300),\n                      hm_Ne =\n                        c(Ne_hm_Fiji,Ne_hm_Fiji10km,Ne_hm_Fiji40km,\n                          Ne_hm_Fiji100km,Ne_hm_Fiji300km))\n\nggplot(fijiwindows, aes(x = SampleWindow, y = hm_Ne)) + geom_point() + \n  geom_line() + ylim(0,20000) + xlim(0,300)\n\n\n\n#ggsave(\"Fiji_Ne_v_SampDistance.pdf\",height = 7, width = 7)\n\n\n\n\n\n\nCalculate Effective Density\n\n# Divide by mean distance between sampling sites to get density\nDe_Fiji <- Ne_hm_Fiji/meandists_Fiji\n#De_all_Fiji <- Ne_all_Fiji / maxdist_Fiji\n\nMean density is 82.3843306 individuals/km. If we do the whole sample as a single population, Ne is “infinite” so this isn’t useful.\n\n\nCalculate sigma\nFollowing Rousset’s (1997) equation:\n\\[\n\\frac{1}{m} = 4D_e\\sigma^2\n\\]\nWhich (Pinsky et al. 2017) re-arranged to give:\n\\[\n\\sigma = \\sqrt{\\frac{1}{4D_em}}\n\\]\nSo now let’s plug that into the first equation!\n\nsigma_fromSlope_Fiji <- sqrt(1 / (4*De_Fiji*slope_Fiji))\n\n#sigma_fromSlope_all_Fiji <- sqrt(1 / (4*De_all_Fiji*slope_Fiji))\n\n\\(\\sigma\\) estimated from this slope is 63.67 km if I use the harmonic mean Ne for density. I can’t use the Ne from the whole population because it is infinite."
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#migraine-method-1",
    "href": "Daruanus_IBD_migrate.html#migraine-method-1",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "MigraiNe Method",
    "text": "MigraiNe Method\n\nRunning MigraiNe\n\nFirst RunSecond RunThird Run\n\n\n\nGenepopFileName=../Daruanus_Fiji.txt\nDemographicModel= LinearIBD\n#I modified the genepop file by adding sampling coordinates as the name of the \n#last individual in each population. These coordinates were distances in km \n#along the Viti Levu reef and coastline from Ovalu in the east to the Yasawas \n#in the northwest: a total of ~414km. I measured all distances in Google Earth\nPSONMax=414 0\n#Neighborhood size is based on mean distance between populations = 46.66\n#414/46.66 = 8.87 so I will use 10 bins\nGeoBinNbr=10\nGeoUnit= ind.km\n#alternate way of specifying the habitat, not used for now\n#habitatPars= 0.5 0.5 400 1 0\n#habitatPars=0 0 0 300 0\n#Mutation Model is K-allele = PIM, with k=2 for SNPs. GivenK is number of alleles\n# at each locus (Daruanus.Fiji@loc.n.all)\nMutationModel=PIM\nGivenK=22,27,8,46,47,30,24,20,52,31,38\nsamplingSpace=,,\nsamplingScale=,,\n#Analysis - this will do 5 runs of 100 points and\n#overwrite those with 10 runs of 250 points\nwriteSequence= Over,Over,Over,Over,Over,Append,10\nStatisticSequence=PAC\nPointNumber=100,100,100,100,100,250\nNrunsperpoint=30,30,30,30,30,50\n#Wide priors on Neu, Nem and g\nLowerBound=0.1,1,0\nUpperbound=1,2500,1\noneDimCI= 2Nmu, 2Nm, Nb, condS2\nCoreNbrForR=4\n#Plots= all1DProfiles\n1DProfiles=2Nmu, 2Nm, Nb, condS2, g\nextrascale=Nb=logscale\ngraphicFormat=pdf\n#writeAdHocFiles=T\n\nThis run completed in 147 minutes\n\n\nA second run where I widen the prior on theta and Nm.\n\nGenepopFileName=../Daruanus_Fiji.txt\nDemographicModel=LinearIBD\n#I modified the genepop file by adding sampling coordinates as the name of the \n#last individual in each population. These coordinates were distances in km \n#along the Viti Levu reef and coastline from Ovalu in the east to the Yasawas \n#in the northwest: a total of ~414km. I measured all distances in Google Earth\nPSONMax=414 0\n#Neighborhood size is based on mean distance between populations = 46.66\n#414/46.66 = 8.87 so I will use 10 bins\nGeoBinNbr=10\nGeoUnit= ind.km\n#alternate way of specifying the habitat, not used for now\n#habitatPars= 0.5 0.5 400 1 0\n#habitatPars=0 0 0 300 0\n#Mutation Model is K-allele = PIM, with k=2 for SNPs. GivenK is number of alleles\n# at each locus (Daruanus.Fiji@loc.n.all)\nMutationModel=PIM\nGivenK=22,27,8,46,47,30,24,20,52,31,38\nsamplingSpace=,,\nsamplingScale=,,\n#Analysis - this will do 5 runs of 100 points and\n#overwrite those with 10 runs of 250 points\nwriteSequence= Over,Over,Over,Over,Over,Append,10\nStatisticSequence=PAC\nPointNumber=100,100,100,100,100,250\nNrunsperpoint=30,30,30,30,30,50\n#Wide priors on Neu, Nem and g\nLowerBound=0.1,1,0\nUpperbound=1,2500,1\noneDimCI= 2Nmu, 2Nm, Nb, condS2\nCoreNbrForR=4\n#Plots= all1DProfiles\n1DProfiles=2Nmu, 2Nm, Nb, condS2, g\nextrascale=Nb=logscale\ngraphicFormat=pdf\n#writeAdHocFiles=T\n\nThis result finished in the same amount of time and with very similar results to the first!\n\n\nRemoving 3 loci and using the condS2 search parameterization\n\nGenepopFileName=../../Daruanus_Fiji.txt\nDemographicModel=LinearIBD\n#I modified the genepop file by adding sampling coordinates as the name of the \n#last individual in each population. These coordinates were distances in km \n#along the Viti Levu reef and coastline from Ovalu in the east to the Yasawas \n#in the northwest: a total of ~414km. I measured all distances in Google Earth\nPSONMax=414 0\n#Neighborhood size is based on mean distance between populations = 46.66\n#414/46.66 = 8.87 so I will use 10 bins\nGeoBinNbr=10\nGeoUnit= ind.km\n#alternate way of specifying the habitat, not used for now\n#habitatPars= 0.5 0.5 400 1 0\n#habitatPars=0 0 0 300 0\n#Mutation Model is K-allele = PIM, with k=2 for SNPs. GivenK is number of alleles\n# at each locus (Daruanus.Fiji@loc.n.all)\nMutationModel=PIM\nGivenK=22,8,46,30,24,20,52,38\nsamplingSpace=,,condS2\nsamplingScale=,,logscale\n#Analysis - this will do 5 runs of 100 points and\n#overwrite those with 10 runs of 250 points\nwriteSequence= Over,Over,Over,Over,Over,Append,10\nStatisticSequence=PAC\nPointNumber=100,100,100,100,100,250\nNrunsperpoint=30,30,30,30,30,50\n#Wide priors on Neu, Nem and g\nLowerBound=0.1,1,1\nUpperbound=2,10000,100000\noneDimCI= 2Nmu, 2Nm, Nb, condS2\nCoreNbrForR=4\n#Plots= all1DProfiles\n1DProfiles=2Nmu, 2Nm, Nb, condS2, g\nextrascale=Nb=logscale\ngraphicFormat=pdf\nwriteAdHocFiles=T\n\nFinished in 112.9333333 minutes.\n\n\n\n\n\nCreate Dispersal Kernels\nThis got me the following estimates.\nOutput from run 2.\n\n\nCode\nrunDir <- \"./Fiji/Migraine/run3\"\nresult <- read_migraine(runDir)\n  \nNS_Fiji <- result[\"NS\"]\nNSCI_Fiji <- c(result[\"NSCI1\"],result[\"NSCI2\"])\nNmu_Fiji <- result[\"Nmu\"]\nNm_Fiji <- result[\"Nm\"]\ng_Fiji <- result[\"g\"]\nlattice2geog_Fiji <- result[\"lattice2geog\"]\n\nsigma2_Fiji <- g_to_sigma2(g_Fiji)\nsigma_fromsigma2_Fiji <- sqrt(sigma2_Fiji*lattice2geog_Fiji)\nsigma_fromNS_Fiji <- sqrt(NS_Fiji/(4*De_Fiji))\nsigmaCI_fromNS_Fiji <- sqrt(NSCI_Fiji/(4*De_Fiji))\n\n\nThe \\(\\sigma\\) we get from Neighborhood Size \\(\\sigma\\) is 31.2. We get a much lower estimate from \\(\\sigma^2\\), with \\(\\sigma\\) = 5.92\n\n\nConfidence Intervals\nPropagating error sorta following Pinsky et al. table S2\n\nError in Effective Size\n\nFor Harmonic Mean MethodFor Whole Sample Method\n\n\n\nNe_estimates_Fiji$JackknifeHigh[which(is.na(Ne_estimates_Fiji$JackknifeHigh))] <- 20000\nNe_estimates_Fiji$JackknifeHigh <- as.numeric(Ne_estimates_Fiji$JackknifeHigh)\nNe_estimates_Fiji$JackknifeLow <- as.numeric(Ne_estimates_Fiji$JackknifeLow)\n\nNe_error_Fiji <- NULL\nfor(n in 1:100000){\n  hm <- harm_mean(mapply(runif, n=1, \n                   min=Ne_estimates_Fiji$JackknifeLow,\n                   max=Ne_estimates_Fiji$JackknifeHigh))\n  Ne_error_Fiji <- c(Ne_error_Fiji,hm)\n}\nnames(Ne_error_Fiji)<-NULL\n#Ne_error_NC <- read_csv(file = \"NC/Ne_error_NC.csv\")$x %>% as.vector\n\nggplot(data = tibble(Ne_error_Fiji), aes(x=Ne_error_Fiji)) + geom_density()\n\n\n\n\n\n\nCan’t do the whole sample method, because Ne estimate is “infinite”\n\n\n\n\n\nError in Effective Density\nWill model the error in meandist as well…\n\nNe_error_Fiji <- read_csv(file = \"Fiji/Ne_error_Fiji.csv\")$x %>% as.vector\nDe_error_Fiji <- Ne_error_Fiji/ rnormTrunc(100000,mean=meandists_Fiji,\n              sd = meandists_Fiji/1.96, min = 1e-10)\n\n\n\nError in Slope\n\nslope_se_Fiji <- summary(lmodel_Fiji)$coefficients[2,2]\n\nggplot(data = tibble(x = c(0,1e-5)), aes(x=x)) + stat_function(fun=dnormTrunc, args = list(mean = slope_Fiji, sd=slope_se_Fiji, min = 0))\n\n\n\nslope_error_Fiji <- rnormTrunc(100000, mean = slope_Fiji, sd = slope_se_Fiji,min = 1e-10)\n\nggplot(data = tibble(slope_error_Fiji), aes(x=slope_error_Fiji)) + geom_density()\n\n\n\nsigma_error_fromSlope_Fiji <- sqrt(1 / (4*De_error_Fiji*slope_error_Fiji))\n\nggplot(data = tibble(sigma_error_fromSlope_Fiji), aes(x=sigma_error_fromSlope_Fiji)) +\n  geom_density() + xlim(0,1000)  + scale_x_log10()\n\n\n\nquantile(sigma_error_fromSlope_Fiji, c(0.025, 0.975))\n\n     2.5%     97.5% \n 5.858928 90.741609 \n\n\n\n\nError in Neighborhood Size\nUsing a uniform distribution is out because there is clearly a peaked distribution in the Migraine output. So I am using a quick fit to a lognormal distribution\n\n\n\nMigraine_Run2_Neighborhood_Theta\n\n\n\nNSCI_Fiji\n\n    NSCI1     NSCI2 \n   122779 101654085 \n\nqlnorm(c(0.025,0.975),meanlog = log(NS_Fiji), sdlog = log(18.89))\n\n[1] 1.010201e+03 1.016589e+08\n\n\n\nNeighborhood_error_Fiji <- rlnormTrunc(n = 100000, meanlog = log(NS_Fiji), \n          sdlog = log(18.89), min = NSCI_Fiji[1], max = NSCI_Fiji[2])\n\nggplot(data = tibble(Neighborhood_error_Fiji), aes(x=Neighborhood_error_Fiji)) + \n  geom_density() + scale_x_log10()\n\n\n\nsigma_error_fromNS_Fiji <- sqrt(Neighborhood_error_Fiji/(4*De_error_Fiji))\n\nnames(sigma_error_fromNS_Fiji) <- NULL\n\nggplot(data = tibble(sigma_error_fromNS_Fiji), \n       aes(x=sigma_error_fromNS_Fiji)) +\n       geom_density() + scale_x_log10()\n\n\n\n\n\n\nPlot Dispersal Kernels\n\nkernelplot_Fiji <- ggplot(data.frame(x=c(0,100)),aes(x)) +\n  map(.x = sample(sigma_error_fromNS_Fiji,1000), .f = function(sigma){\n            stat_function(fun = dexp, args = list(rate = 1/sigma),\n                   colour = \"lightblue\",\n                   linetype=1,size=0.1,alpha = 0.2) }) +\n  map(.x = sample(sigma_error_fromSlope_Fiji,1000), .f = function(sigma){\n         stat_function(fun = dexp, args = list(rate = 1/sigma),\n                     colour = \"lightgreen\",\n                    linetype=1,size=0.1,alpha = 0.2) }) +\n                stat_function(fun=dexp,args=list(rate = 1/sigma_fromSlope_Fiji), \n                              linetype=2,aes(color=\"IBD_Slope\"),show.legend = T) +\n                stat_function(fun=dexp,args=list(rate = 1/sigma_fromsigma2_Fiji), \n                              linetype=2,aes(color=\"Migraine_Sigma2\"), \n                              show.legend = T) +\n                stat_function(fun=dexp,args=list(rate = 1/sigma_fromNS_Fiji), \n                              linetype=2,aes(color=\"Migraine_Neighborhood_Size\"), \n                              show.legend = T) + \n                                xlab(\"Alongshore Distance (km)\") +\n                                ylab(\"Dispersal probability density\") +\n                              scale_color_manual(\"Kernel\",values = \n                    c(Migraine_Sigma2=\"darkblue\", \n                    Migraine_Neighborhood_Size =\"blue\",\n                    IBD_Slope = \"green\")) + ylim(0,0.05)\n\n\nkernelplot_Fiji\n\n\n\n\nThe reason that the error is generally smaller than the estimate is because the upper bounds of Ne are often unbounded, and treated as 20,000."
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#traditional-isolation-by-distance-method-2",
    "href": "Daruanus_IBD_migrate.html#traditional-isolation-by-distance-method-2",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "Traditional Isolation by Distance Method",
    "text": "Traditional Isolation by Distance Method\nBased on the OG (Rousset 1997) estimator from slope of the IBD regression.\n\nCalculate distance matrices\n\nGenetic Distances\nWeir and Cockerham’s Fst and other basic stats.\n\nDaruanus.FP.hfst <- genind2hierfstat(Daruanus.FP)\nDaruanus.FP.loci <- genind2loci(Daruanus.FP)\n#gen.loci <- genind2loci(gen)\nstats.FP <- basic.stats(Daruanus.FP)\ntheta.FP <- theta.msat(Daruanus.FP.loci)\n#mean theta\nmean(theta.FP[,2])\n\n[1] 53.37003\n\nfst.FP <- genet.dist(Daruanus.FP.hfst, method = \"WC84\")\n# mean Fis values\nstats.FP$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\n# linearize\nfst.FP <- fst.FP/(1-fst.FP)\n#write.csv(as.matrix(fst.FP), \"Daruanus_FP_linearizedFst.csv\", row.names = F, quote=F)\n\n\nGeographic Distances\nCalculate great circle distance\n\ngcdists_FP <- as.dist(pointDistance(FPpops[,c(5,4)], lonlat=T)/1000)\nattr(gcdists_FP, \"Labels\") <- FPpops$Abbr\ngcdists.mat_FP <- as.matrix(gcdists_FP)\n\nNow to follow what Malin did, and create a principal components axis, and measure distance along it.\n\n# because we only care about the x axis, we need to reorder,so that Tetiaroa comes after Puna and before Temae\nFPpops <- FPpops[c(1,4,2,3,5),]\nFPpops.sp <- SpatialPointsDataFrame(FPpops[,c(5,4)], data = FPpops, \n               proj4string = CRS(\"+proj=longlat  +datum=WGS84\"))\nFPpops.utm <- spTransform(FPpops.sp, CRS(\"+proj=utm +zone=56 +datum=WGS84\"))\n#as.dist(pointDistance(localities.utm,latlon=F)/1000)\n#principal components without scaling or centering, we just want the rotation\npc_FP <- prcomp(FPpops.utm@coords, retx=T, scale=F,center=F)\nplot(pc_FP$x)\n\n\n\n#set PC2 axis to zero\npc1_FP<-cbind(pc_FP$x[,1],0)\n\n\npcdists_FP <- as.dist(pointDistance(pc1_FP,lonlat=F)/1000)\n\nattr(pcdists_FP, \"Labels\") <- FPpops$Abbr\n#write.csv(as.matrix(pcdists), \"Apercula_pcdists.csv\", row.names = T, quote=F)\n\n\npcdists.mat_FP <- as.matrix(pcdists_FP)\n\n#pull out a few other distances we'll need\nneighbordists_FP <- pcdists.mat_FP[row(pcdists.mat_FP) == col(pcdists.mat_FP) + 1]\ndistfromP1_FP <- pcdists.mat_FP[,1]\nmaxdist_FP <- max(pcdists.mat_FP)\nmeandists_FP <- mean(neighbordists_FP)\n\nMean sampling distance is 86.1473678 km. But note that Tetiaroa occurs only a couple of kilometers from the Moorea population because they are being forced onto the rotated X axis.\n\n\n\n\nCalculate linear model\nFirst to get the slope \\(m\\) we need to make a simple linear model. I don’t think significance is really important here, but we can calculate that with a Mantel test.\n\n# mantel test\nmantelt<-mantel.randtest(fst.FP,pcdists_FP, nrepet = 10000)\n\ndistances <- tibble(distance=as.vector(pcdists_FP),fst=as.vector(fst.FP))\n\nlmodel_FP <- lm(fst ~ distance , distances)\n\nslope_FP <- lmodel_FP$coefficients[2]\nmantelr <- round(mantelt$obs, 2)\npvalue <- round(mantelt$pvalue, 5)\n\nlmodel_plot_FP <- ggplot(distances,aes(x=distance,y=fst)) +\n          geom_point() + geom_smooth(method=lm) + \n                    xlab(\"Geographic Distance (km)\") + \n          ylab(expression(F[\"ST\"]/1-F[\"ST\"])) + \n          geom_text(label = paste(\"m =\", slope_FP, \"; Mantel r =\", \n                                  mantelr,\", p =\", pvalue ), \n                       mapping = aes(x = 80, y = -0.002))\n\nlmodel_plot_FP\n\n\n\n#ggsave(\"FP_IBD.pdf\", plot=lmodel_plot,device=\"pdf\", width=7, height=5,units=\"in\")\n\nE voila, c’est positive! But not significantly so.\n\n\nCalculate Effective Size\nPull out just the relevant FP estimates of Ne. The negative numbers reflect very high values of Ne!\n\nNe_estimates_FP <- Ne_estimates_f %>% filter(Population %in% FPpops$Abbr)\n\nNe_estimates_FP[,c(1:4,8,11,12)]\n\n\n\n  \n\n\n# harmonic mean of Ne, following Waples and Do 2010\nNe_hm_FP <- harm_mean(Ne_estimates_FP$Ne)\n\n\n\nNe vs. Sampling Window\nLet’s cluster the sites by UPGMA (using Euclidean distances)\n\nplot(hclust(pcdists_FP,\"average\"))\n\n\n\n\n\n10km20km40km300km (all pops as one)Figure\n\n\n\nstats.FP$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\nmeanFis_FP <- stats.FP$Fis %>% as_tibble() %>%\n  summarize(across(everything(),mean, na.rm=TRUE)) %>% summarize(meanFis = rowMeans(.))\n\nDaruanus.FP.10km <- Daruanus.FP\n\nDaruanus.FP.10km@pop <-  Daruanus.FP.10km@pop %>% fct_collapse(\n   TemTetia = c(\"Tetia\",\"Tem\")\n )\n\nDaruanus.FP.10km.stats <- basic.stats(Daruanus.FP.10km)\n\nDaruanus.FP.10km.stats$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\nmeanFis_FP_10km <- Daruanus.FP.10km.stats$Fis %>% as_tibble() %>%\n  summarize(across(everything(),mean, na.rm=TRUE)) %>% summarize(meanFis = rowMeans(.))\n\n#genind_to_genepop(Daruanus.FP.10km,output = \"Daruanus/FP/Daruanus_FP_10km.txt\")\n\nNe_estimates_FP10km <- read_NeEstimator(\n                        \"NeEstimator/Daruanus_LDNe_FP_10kmxLD.txt\")\n\nNe_estimates_FP10km <- WDFilter(Ne_estimates_FP10km, 10)\n\n\nNe_hm_FP10km <- harm_mean(Ne_estimates_FP10km$Ne)\n\n\n\n\nDaruanus.FP.20km <- Daruanus.FP\n\nDaruanus.FP.20km@pop <-  Daruanus.FP.20km@pop %>% fct_collapse(\n   TemTetiaMo = c(\"Tetia\",\"Tem\",\"Mo\")\n )\n\nDaruanus.FP.20km.stats <- basic.stats(Daruanus.FP.20km)\n\nDaruanus.FP.20km.stats$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\nmeanFis_FP_20km <- Daruanus.FP.20km.stats$Fis %>% as_tibble() %>%\n  summarize(across(everything(),mean, na.rm=TRUE)) %>% summarize(meanFis = rowMeans(.))\n\n#genind_to_genepop(Daruanus.FP.20km,output = \"Daruanus/FP/Daruanus_FP_20km.txt\")\n\nNe_estimates_FP20km <- read_NeEstimator(file = \"NeEstimator/Daruanus_LDNe_FP_20kmxLD.txt\")\nNe_estimates_FP20km <- WDFilter(Ne_estimates_FP20km, 10)\n\nNe_hm_FP20km <- harm_mean(Ne_estimates_FP20km$Ne)\n\n\n\n\nDaruanus.FP.40km <- Daruanus.FP\n\nDaruanus.FP.40km@pop <-  Daruanus.FP.40km@pop %>% fct_collapse(\n   East = c(\"Tetia\",\"Tem\",\"Mo\",\"Puna\")\n )\n\nDaruanus.FP.40km.stats <- basic.stats(Daruanus.FP.40km)\n\nDaruanus.FP.40km.stats$Fis %>% as_tibble() %>% summarize(across(everything(),mean, na.rm=TRUE))\n\n\n\n  \n\n\nmeanFis_FP_40km <- Daruanus.FP.40km.stats$Fis %>% as_tibble() %>%\n  summarize(across(everything(),mean, na.rm=TRUE)) %>% summarize(meanFis = rowMeans(.))\n\n#genind_to_genepop(Daruanus.FP.40km,output = \"Daruanus/FP/Daruanus_FP_40km.txt\")\n\nNe_estimates_FP40km <- read_NeEstimator(file = \"NeEstimator/Daruanus_LDNe_FP_40kmxLD.txt\")\nNe_estimates_FP40km <- WDFilter(Ne_estimates_FP40km, 10)\n\nNe_hm_FP40km <- harm_mean(Ne_estimates_FP40km$Ne)\n\n\n\n\nNe_estimates_FP300km <- read_NeEstimator(file =\n                                             \"NeEstimator/Daruanus_LDNe_FP_1popxLD.txt\")\nNe_estimates_FP300km <- WDFilter(Ne_estimates_FP300km, 10)\n\n\n\nNe_hm_FP300km <- Ne_estimates_FP300km$Ne\nNe_all_FP <- Ne_estimates_FP300km$Ne\n\nNe_all_FP_CI <- c(Ne_estimates_FP300km$ParametricLow,20000)\n\n\n\n\nFPwindows <- tibble(SampleWindow = c(0,10,40,300),\n        hm_Ne = c(Ne_hm_FP,Ne_hm_FP10km,Ne_hm_FP40km,Ne_hm_FP300km))\n\nFPNevDistance <- ggplot(FPwindows, aes(x = SampleWindow, y = hm_Ne)) + \n                  geom_point() + geom_line() + ylim(0,20000) + xlim(0,300)\nFPNevDistance\n\n\n\n#ggsave(\"FP_Ne_v_SampDistance.pdf\", height = 7, width = 7)\n\n\n\n\n\n\nCalculate Effective Density\n\n# Divide by mean distance between sampling sites to get density\nDe_FP <- Ne_hm_FP/meandists_FP\nDe_all_FP <- Ne_all_FP/maxdist_FP\n\nMean density in the Societies is 11.807568 inds/km, or really really large if we consider the whole sample as a single population 34.9942393\n\n\nCalculate sigma\nFollowing Rousset’s (1997) equation:\n\\[\n\\frac{1}{m} = 4D_e\\sigma^2\n\\]\nWhich (Pinsky et al. 2017) re-arranged to give:\n\\[\n\\sigma = \\sqrt{\\frac{1}{4D_em}}\n\\]\nSo now let’s plug that into the first equation!\n\nsigma_fromSlope_FP <- sqrt(1 / (4*De_FP*slope_FP))\n\nsigma_fromSlope_all_FP <- sqrt(1 / (4*De_all_FP*slope_FP))\n\nSo effective density is 11.81 individuals per km, and \\(\\sigma\\) is 64.23 km if we calculate density based on harmonic mean of Ne, or rsignif(sigma_fromSlope_all_FP,4)` km if we calculate it across the whole sample."
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#migraine-method-2",
    "href": "Daruanus_IBD_migrate.html#migraine-method-2",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "MigraiNe Method",
    "text": "MigraiNe Method\n\nRunning MigraiNe\n\nFirst RunSecond RunFifth Run\n\n\nI modified the genepop file by adding sampling coordinates as the name of the last individual in each population. There is no coastline for these samples, which each come from different islands. I just measured from Tahiti to Maupiti It’s 65 km from the tip of Tahiti Iti to Puna, so I added that to each coordinate\n\ndistfromP1_FP+65\n\n     Puna     Tetia       Tem        Mo     Tahaa \n 65.00000  73.17410  90.15654 116.74566 393.24127 \n\n\n\nGenepopFileName=../Daruanus_FP.txt\nDemographicModel= LinearIBD\n#I modified the genepop file by adding sampling coordinates as the name of the \n#last individual in each population. There is no coastline for these samples,\n# which each come from different islands. I just measured from Tahiti to Maupiti\n# It's 65 km from the tip of Tahiti Iti to Puna, so I added that to \n# each coordinate.\nPSONMax=355 0\n#Neighborhood size is based on mean distance between populations = 75.78\n#355/75.78 = 4.684 so I will use 6 bins\nGeoBinNbr=6\nGeoUnit= ind.km\n#alternate way of specifying the habitat, not used for now\n#habitatPars= 0.5 0.5 400 1 0\n#habitatPars=0 0 0 300 0\n#Mutation Model is K-allele = PIM, with k=2 for SNPs. GivenK is number of alleles\n# at each locus (Daruanus.FP@loc.n.all)\nMutationModel=PIM\nGivenK=21,24,8,37,43,26,19,16,43,31,40\nsamplingSpace=,,\nsamplingScale=,,\n#Analysis - this will do 5 runs of 100 points and\n#overwrite those with 10 runs of 250 points\nwriteSequence= Over,Over,Over,Over,Over,Append,10\nStatisticSequence=PAC\nPointNumber=100,100,100,100,100,250\nNrunsperpoint=30,30,30,30,30,50\n#Wide priors on Neu, Nem and g\nLowerBound=0.1,1,0\nUpperbound=2,10000,1\noneDimCI= 2Nmu, 2Nm, Nb, condS2\nCoreNbrForR=4\n#Plots= all1DProfiles\n1DProfiles=2Nmu, 2Nm, Nb, condS2, g\nextrascale=Nb=logscale\ngraphicFormat=pdf\n#writeAdHocFiles=T\n\nThe first run finished with an error, but a second identical run completed in 50.8666667 minutes. Both runs had very similar results.\n\n\nWidened the prior on theta because the first two runs were over\n\nGenepopFileName=../Daruanus_FP.txt\nDemographicModel= LinearIBD\n#I modified the genepop file by adding sampling coordinates as the name of the \n#last individual in each population. There is no coastline for these samples,\n# which each come from different islands. I just measured from Tahiti to Maupiti\n# It's 65 km from the tip of Tahiti Iti to Puna, so I added that to \n# each coordinate.\nPSONMax=355 0\n#Neighborhood size is based on mean distance between populations = 75.78\n#355/75.78 = 4.684 so I will use 6 bins\nGeoBinNbr=6\nGeoUnit= ind.km\n#alternate way of specifying the habitat, not used for now\n#habitatPars= 0.5 0.5 400 1 0\n#habitatPars=0 0 0 300 0\n#Mutation Model is K-allele = PIM, with k=2 for SNPs. GivenK is number of alleles\n# at each locus (Daruanus.FP@loc.n.all)\nMutationModel=PIM\nGivenK=21,24,8,37,43,26,19,16,43,31,40\nsamplingSpace=,,\nsamplingScale=,,\n#Analysis - this will do 5 runs of 100 points and\n#overwrite those with 10 runs of 250 points\nwriteSequence= Over,Over,Over,Over,Over,Append,10\nStatisticSequence=PAC\nPointNumber=100,100,100,100,100,250\nNrunsperpoint=30,30,30,30,30,50\n#Wide priors on Neu, Nem and g\nLowerBound=0.1,1,0\nUpperbound=4,10000,1\noneDimCI= 2Nmu, 2Nm, Nb, condS2\nCoreNbrForR=4\n#Plots= all1DProfiles\n1DProfiles=2Nmu, 2Nm, Nb, condS2, g\nextrascale=Nb=logscale\ngraphicFormat=pdf\n#writeAdHocFiles=T\n\n\n\nRemoved 3 loci, used condS2 parameterization\n\nGenepopFileName=../../Daruanus_FP.txt\nDemographicModel= LinearIBD\n#I modified the genepop file by adding sampling coordinates as the name of the \n#last individual in each population. There is no coastline for these samples,\n# which each come from different islands. I just measured from Tahiti to Maupiti\n# It's 65 km from the tip of Tahiti Iti to Puna, so I added that to \n# each coordinate.\nPSONMax=355 0\n#Neighborhood size is based on mean distance between populations = 75.78\n#355/75.78 = 4.684 so I will use 6 bins\nGeoBinNbr=6\nGeoUnit= ind.km\n#alternate way of specifying the habitat, not used for now\n#habitatPars= 0.5 0.5 400 1 0\n#habitatPars=0 0 0 300 0\n#Mutation Model is K-allele = PIM, with k=2 for SNPs. GivenK is number of alleles\n# at each locus (Daruanus.FP@loc.n.all)\nMutationModel=PIM\nGivenK=21,8,37,26,19,16,43,40\nsamplingSpace=,,condS2\nsamplingScale=,,logscale\n#Analysis - this will do 5 runs of 100 points and\n#overwrite those with 10 runs of 250 points\nwriteSequence= Over,Over,Over,Over,Over,Append,10\nStatisticSequence=PAC\nPointNumber=100,100,100,100,100,250\nNrunsperpoint=30,30,30,30,30,50\n#Wide priors on Neu, Nem and g\nLowerBound=0.1,1,1\nUpperbound=4,10000,100000\noneDimCI= 2Nmu, 2Nm, Nb, condS2, g\nCoreNbrForR=4\nPlots= allProfiles\n#1DProfiles=2Nmu, 2Nm, Nb, condS2, g\nextrascale=Nb=logscale\ngraphicFormat=pdf\nwriteAdHocFiles=T\n\nFinished in 56.45 minutes.\n\n\n\n\n\nCreate Dispersal Kernels\n\nSigma estimates\nThis got me the following estimates.\nOutput from run 5.\n\n\nCode\nrunDir <- \"./FP/Migraine/run5\"\nresult <- read_migraine(runDir)\n  \nNS_FP <- result[\"NS\"]\nNSCI_FP <- c(result[\"NSCI1\"],result[\"NSCI2\"])\nNmu_FP <- result[\"Nmu\"]\nNm_FP <- result[\"Nm\"]\ng_FP <- result[\"g\"]\nlattice2geog_FP <- result[\"lattice2geog\"]\n\nsigma2_FP <- g_to_sigma2(g_FP)\nsigma_fromsigma2_FP <- sqrt(sigma2_FP*lattice2geog_FP)\nsigma_fromNS_FP <- sqrt(NS_FP/(4*De_FP))\nsigmaCI_fromNS_FP <- sqrt(NSCI_FP/(4*De_FP))\n\nsigma_fromNS_all_FP <- sqrt(NS_FP/(4*De_all_FP))\nsigmaCI_fromNS_all_FP <- sqrt(NSCI_FP/(4*De_all_FP))\n\n\nThe \\(\\sigma\\) we get from \\(F_{ST}\\) ~ Distance is 64.2, and from Neighborhood Size \\(\\sigma\\) is 88. We again get a lower estimate from \\(\\sigma^2\\), with \\(\\sigma\\) = 15\n\n\n\nConfidence Intervals\nPropagating error sorta following Pinsky et al. table S2\n\nError in Ne\n\nFor Harmonic Mean MethodFor Whole Sample Method\n\n\nFollowing Pinsky, Montes, and Palumbi (2010) I am going to bootstrap across the confidence intervals for each Nb estimate. Unfortunately, the new jackknife method of Jones, Ovenden, and Wang (2016) often results in infinite upper bounds with marine data. I’m going to use the jackknife CIs. I’m also going to use a uniform distribution for the error because approximating the error structure with ChiSq or Normal distributions is not a simple task and I’m just trying to get a sketch of the error to compare with MigraiNe anyway. I’m going to set “Infinite” values in the upper CI to 20,000 since I rarely see upper bounds that high.\n\n\nCode\nNe_estimates_FP$JackknifeHigh[which(is.na(Ne_estimates_FP$JackknifeHigh))] <- 20000\nNe_estimates_FP$JackknifeHigh <- as.numeric(Ne_estimates_FP$JackknifeHigh)\nNe_estimates_FP$JackknifeLow <- as.numeric(Ne_estimates_FP$JackknifeLow)\n\nNe_error_FP <- NULL\nfor(n in 1:100000){\n  hm <- harm_mean(mapply(runif, n=1, \n                   min=Ne_estimates_FP$JackknifeLow,\n                   max=Ne_estimates_FP$JackknifeHigh))\n  Ne_error_FP <- c(Ne_error_FP,hm)\n}\nnames(Ne_error_FP) <- NULL\n#write.csv(Ne_error_FP, \"FP/Ne_error_FP.csv\",quote=F,row.names = F)\nggplot(data = tibble(Ne_error_FP), aes(x=Ne_error_FP)) + geom_density()\n\n\n\n\n\n\n\nNaaykens and D’Aloia showed that using the whole sample to estimate density gives pretty similar results to the harmonic mean method, so I’m also going to try that.\n\n\nCode\nNb <- Ne_all_FP\nr2_FP <- Ne_estimates_FP300km$r2\n#from Waples 2006 table 2\ner2_FP <- 1/Ne_estimates_FP300km$SampSize + 3.19/Ne_estimates_FP300km$SampSize ^2 \ndf_FP <- Ne_estimates_FP300km$IndAlleles\n\nWaplesMonoNe(r2_FP - er2_FP)\n\n\n[1] 11688.35\n\n\nCode\n# this shows that we can get approximately what NeEstimator gives us... \n#not sure why its not exact... must be missing some correction\nrCI_FP <- df_NC*r2_FP / (qchisq(c(0.025,0.975), df = df_FP))\nWaplesMonoNe(rCI_NC - er2_NC)\n\n\n[1]  3729.688 16288.111\n\n\nCode\n#and now to get and plot the error distribution\nNe_error_all_FP <- WaplesMonoNe(((df_FP*r2_FP)/(rchisq(100000, df = df_FP))) - er2_FP)\n\nggplot(data = tibble(Ne_error_all_FP), aes(x=Ne_error_all_FP)) + \n  geom_density() + xlim(0,30000)\n\n\n\n\n\n\n\n\n\n\nError in Effective Density\n\n\nCode\nNe_error_FP <- read_csv(file = \"FP/Ne_error_FP.csv\")$x %>% as.vector\n\nDe_error_FP <- Ne_error_FP /rnormTrunc(100000, mean = meandists_FP,\n                    sd = (65-10)/1.96, min = 1e-10)\n\nDe_error_all_FP <- Ne_error_all_FP / maxdist_FP\n\nggplot(data = tibble(De_error_FP), aes(x=De_error_FP)) +\n  geom_density() + xlim(0,1000)\n\n\n\n\n\nCode\nggplot(data = tibble(De_error_all_FP), aes(x=De_error_all_FP)) +\n  geom_density() + xlim(0,1000)\n\n\n\n\n\n\n\nError in Slope\n\n\nCode\nslope_se_FP <- summary(lmodel_FP)$coefficients[2,2]\n\nggplot(data = tibble(x = c(1e-6,1e-4)), aes(x=x)) + stat_function(fun=dnormTrunc, args = list(mean = slope_FP, sd=slope_se_FP, min = 0))\n\n\n\n\n\nCode\nslope_error_FP <- rnormTrunc(100000, mean = slope_FP, sd = slope_se_FP,min = 1e-10)\n\nggplot(data = tibble(slope_error_Fiji), aes(x=slope_error_Fiji)) + geom_density()\n\n\n\n\n\nCode\nsigma_error_fromSlope_FP <- sqrt(1 / (4*De_error_FP*slope_error_FP))\n\nsigma_error_fromSlope_all_FP <- sqrt(1 / (4*De_error_all_FP*slope_error_FP))\n\nggplot(data = tibble(sigma_error_fromSlope_FP), aes(x=sigma_error_fromSlope_FP)) +\n  geom_density() + xlim(0,1000)\n\n\n\n\n\nCode\nggplot(data = tibble(sigma_error_fromSlope_all_FP), aes(x=sigma_error_fromSlope_all_FP)) +\n  geom_density() + xlim(0,1000)\n\n\n\n\n\nCode\nquantile(sigma_error_fromSlope_FP, c(0.025, 0.975))\n\n\n     2.5%     97.5% \n 10.36456 100.46865 \n\n\n\n\nError in Neighborhood Size\nUsing a uniform distribution is out because there is clearly a peaked distribution in the Migraine output. So I am using a quick fit to a truncated lognormal distribution\n\n\n\nMigraine_Run2_Neighborhood_Theta\n\n\n\nNSCI_FP\n\n       NSCI1        NSCI2 \n       67763 531462708061 \n\ncurve(dlnorm(x, meanlog = log(NS_FP), sdlog = log(7.9), log = T))\n\n\n\nqlnorm(c(0.025,0.975),meanlog = log(NS_FP), sdlog = log(206.5))\n\n[1] 1.062342e+01 1.260620e+10\n\n\n\n\nCode\nNeighborhood_error_FP <- rlnormTrunc(n = 100000, meanlog = log(NS_FP), \n                                     sdlog = log(210), min = NSCI_FP[1], max = Inf)\n\n\nggplot(data = tibble(Neighborhood_error_FP), aes(x=Neighborhood_error_FP)) + \n  geom_density() + scale_x_log10()\n\n\n\n\n\nCode\nsigma_error_fromNS_FP <- sqrt(Neighborhood_error_FP/(4*De_error_FP))\n\nsigma_error_fromNS_all_FP <- sqrt(Neighborhood_error_FP/(4*De_error_all_FP))\n\nnames(sigma_error_fromNS_FP) <- NULL\n\nggplot(data = tibble(sigma_error_fromNS_FP), \n       aes(x=sigma_error_fromNS_FP)) +\n       geom_density() + scale_x_log10()\n\n\n\n\n\n\n\nPlot Dispersal Kernels\n\n\nCode\nkernelplot_FP <- ggplot(data.frame(x=c(0,100)),aes(x)) + \n  map(.x = sample(sigma_error_fromNS_FP,1000), .f = function(sigma){\n    stat_function(fun = dexp, args = list(rate = 1/sigma),\n           colour = \"lightblue\",                                       linetype=1,size=0.1,alpha = 0.2) }) +\n    map(.x = sample(sigma_error_fromSlope_FP,1000), \n        .f = function(sigma){\n         stat_function(fun = dexp, args = list(rate = 1/sigma),\n                colour = \"lightgreen\",                                       linetype=1,size=0.1,alpha = 0.2) }) +\n      stat_function(fun=dexp,args=list(rate = 1/sigma_fromSlope_FP), linetype=2,\n                    aes(color=\"IBD_Slope\"), show.legend = T) +\n      stat_function(fun=dexp,args=list(rate = 1/sigma_fromSlope_all_FP), linetype=2,\n                              aes(color=\"IBD_Slope_1pop\"),\n                                                          show.legend = T) +\n      stat_function(fun=dexp,args=list(rate = 1/sigma_fromsigma2_FP), linetype=2,\n                              aes(color=\"Migraine_Sigma2\"), \n                                                          show.legend = T) +\n      stat_function(fun=dexp,args=list(rate = 1/sigma_fromNS_FP), linetype=2,\n                           aes(color=\"Migraine_Neighborhood_Size\"), \n                                                    show.legend = T) +\n      stat_function(fun=dexp,args=list(rate = 1/sigma_fromNS_all_FP), linetype=2,\n                           aes(color=\"Migraine_Neighborhood_Size_1pop\"),\n                                                    show.legend = T) +\n      xlab(\"Alongshore Distance (km)\") + \n        ylab(\"Dispersal probability density\") +\n      scale_color_manual(\"Kernel\",values = \n                    c(IBD_Slope = \"green\",\n                     IBD_Slope_1pop = \"darkgreen\",\n                     Migraine_Sigma2=\"darkblue\", \n                      Migraine_Neighborhood_Size =\"blue\",\n                      Migraine_Neighborhood_Size_1pop = \"cyan4\")) +\n      ylim(0,0.1)\n\n\nkernelplot_FP"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#make-figures-for-the-proposal",
    "href": "Daruanus_IBD_migrate.html#make-figures-for-the-proposal",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "Make figures for the proposal",
    "text": "Make figures for the proposal\n\n\nCode\nerrors.p <- enframe(c(`New Caledonia` = sigma_error_fromNS_NC,\n                    Fiji = sigma_error_fromSlope_Fiji,\n                    Societies = sigma_error_fromSlope_FP),\n                  name = \"Archipelago\", \n                  value = \"Sigma\") %>% \n                mutate(Archipelago = str_remove(Archipelago, pattern=\"\\\\d+$\"))\n\n#create a tibble with the point estimates of interest\npoint_estimates <- across.archipelagos.df %>%  select(\"Archipelago\",\"sigma from slope\") %>% \n  mutate(`sigma from slope` = replace(`sigma from slope`,2,\n                                      across.archipelagos.df$`sigma from NS`[2])) \n\n\nviolins.p <- errors.p %>% remove_missing() %>% \n  mutate(Archipelago = factor(Archipelago,levels = c(\"New Caledonia\",\n                                                     \"Fiji\",\"Societies\"))) %>% \n  ggplot() + geom_violin(mapping = aes(x = Archipelago, y = Sigma)) + \n   geom_point(data = point_estimates, \n             mapping = aes(x = Archipelago, y = `sigma from slope`), \n             color = \"grey\", size = 5) +\n  ylim(0,1000) +\n    coord_cartesian(ylim = c(1, 1000)) + \n  scale_y_log10()\n\n#ggsave(\"Daruanus_archipelagos_violins.pdf\",violins.p)\n\n\n\nkernelplot_archipelagos <- ggplot(data.frame(x=c(0,250)),aes(x)) + \n  map(.x = sample(sigma_error_fromNS_NC,500), .f = function(sigma){\n          stat_function(fun = dexp, args = list(rate = 1/sigma),\n                  colour = \"palevioletred\",\n                  linetype=1,size=0.1,alpha = 0.1) }) +\n   map(.x = sample(sigma_error_fromSlope_Fiji,500), .f = function(sigma){\n                  stat_function(fun = dexp, args = list(rate = 1/sigma),\n                 colour = \"goldenrod\", \n                 linetype=1,size=0.1,alpha = 0.1) }) +\n   map(.x = sample(sigma_error_fromSlope_FP,500), .f = function(sigma){\n                stat_function(fun = dexp, args = list(rate = 1/sigma),\n                 colour = \"lightblue\",\n                 linetype=1,size=0.1,alpha = 0.1) }) +\n  stat_function(fun=dexp,args=list(rate = 1/sigma_fromNS_NC), linetype=1,\n                aes(color=\"New Caledonia\"), show.legend = T) +\n  stat_function(fun=dexp,args=list(rate = 1/sigma_fromSlope_Fiji), linetype=1,\n                              aes(color=\"Fiji\"), \n                                                          show.legend = T) +\n  stat_function(fun=dexp,args=list(rate = 1/sigma_fromSlope_FP), linetype=1,\n                              aes(color=\"Societies\"), \n                                                      show.legend = T) +\n  xlab(\"Alongshore Distance (km)\") + ylab(\"Dispersal probability density\") +\n  scale_color_manual(\"Archipelago\",values = \n                    c(`New Caledonia` = \"red\",\n                      Fiji = \"orange\",\n                      Societies=\"blue\" \n                   )) +\n  ylim(0,0.02)\n\nkernelplot_archipelagos\n\n\n\n\n\nCode\n#ggsave(\"Darunaus_archipelagos_kernels.pdf\", kernelplot_archipelagos)\n\n\n\nViolin PlotsBox PlotsFinal Figure\n\n\n\nviolins\n\n\n\n\n\n\n\nboxes\n\n\n\n\n\n\n\nkernelplot_archipelagos"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#convert-data",
    "href": "Daruanus_IBD_migrate.html#convert-data",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "Convert data",
    "text": "Convert data\nHere is code to convert genepop format to treemix format:\n\n\nCode\npops <- c(\"PNG\",\"New Caledonia\",\"Fiji\", \"Societies\",\"Tuamotus\")\nloci <- c(\"Locus_1\",\"Locus_2\",\"Locus_3\",\"Locus_4\",\"Locus_5\",\"Locus_6\",\n       \"Locus_7\",\"Locus_8\")\n\nDaruanus4pop <- read.genepop(\"Daruanus/Daruanus_All_8locus_5pops.gen\", \n                             ncode = 3L)\nlevels(Daruanus4pop@pop)<- pops\n\n\nDaruanus4pop.gtypes <- genind2gtypes(Daruanus4pop)\n\npopmatrix <- tibble(Daruanus4pop.gtypes@data) %>% \n                    mutate(allele = as.numeric(allele)) %>% \n                    group_by(stratum,locus)\n                        \n\npopsumlong <- popmatrix  %>%  summarize(mean = mean(allele,na.rm=T), \n                      var = var(allele, na.rm=T),\n                           n = n())\n\npopsumwide <- popsumlong %>% pivot_wider(names_from = stratum, \n                      values_from = c(mean,var,n))\n\npopsumwide <- popsumwide[,c(\"mean_PNG\",\"var_PNG\",\"n_PNG\",\n               \"mean_New Caledonia\",\"var_New Caledonia\",\n               \"n_New Caledonia\",\n               \"mean_Fiji\",\"var_Fiji\",\"n_Fiji\",\n               \"mean_Societies\",\"var_Societies\",\"n_Societies\",\n                \"mean_Tuamotus\",\"var_Tuamotus\",\"n_Tuamotus\")]\n\n#write_csv(popsumwide,\"Daruanus/treemix/Daruanus_treemix.txt\")\n\n\nDid a search and replace in bbedit to make the final file format, and then gzipped it.\nSearch: (,[\\d\\.]+,\\d+),\nReplace \\1"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#explore-treemix",
    "href": "Daruanus_IBD_migrate.html#explore-treemix",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "Explore Treemix",
    "text": "Explore Treemix\nInstalled Treemix on Argonaute via Mamba. Had to follow these instructions to add libgsl.so.25 to /etc/ld.so.conf first\nI’m first going to try a variety of m values and root at New Caledonia and Tuamotus.\n\n\nCode\n(base) eric@Saraswati ~/github/IBD_Kernels/Daruanus/treemix$ treemix -i Daruanus_treemix.txt.gz -o PNG_0m -micro -root PNG -global                                                                                          \n\nTreeMix v. 1.13\n$Revision: 231 $\n\nnpop:5 nsnp:8\nEstimating covariance matrix in 8 blocks of size 1\nSEED: 1670724878\nStarting from:\n((Fiji:4.44185,Tuamotus:7.32221):0,Societies:0);\nAdding PNG [4/5]\nln(likelihood): -17.411228 \n(PNG:5.50807,(Fiji:1.12789,(Tuamotus:4.74938,Societies:0):5.11134):5.50807);\nAdding NewCaledonia [5/5]\nln(likelihood): -25.594418 \n((Fiji:1.60844,(PNG:6.74548,NewCaledonia:0):3.60694):2.43321,(Tuamotus:4.78333,Societies:0):2.43321);\nTesting global rearrangements\nFiji:1.60844 PNG:6.74548\n-26.530906 -25.594418\nFiji:1.60844 Societies:0\n-28.39933 -25.594418\nPNG:6.74548 Fiji:1.60844\n-26.530906 -25.594418\nNewCaledonia:0 Tuamotus:4.78333\n-28.219739 -25.594418\nSocieties:0 Fiji:1.60844\n-28.39933 -25.594418\nSet root above PNG\nDONE.\n\n\ntreemix -i Daruanus_treemix.txt.gz -o PNG_0m -micro -root PNG -global -m 0\ntreemix -i Daruanus_treemix.txt.gz -o PNG_1m -micro -root PNG -global -m 1\ntreemix -i Daruanus_treemix.txt.gz -o PNG_2m -micro -root PNG -global -m 2\ntreemix -i Daruanus_treemix.txt.gz -o PNG_3m -micro -root PNG -global -m 3\ntreemix -i Daruanus_treemix.txt.gz -o PNG_4m -micro -root PNG -global -m 4\ntreemix -i Daruanus_treemix.txt.gz -o PNG_5m -micro -root PNG -global -m 5\ntreemix -i Daruanus_treemix.txt.gz -o PNG_6m -micro -root PNG -global -m 6\n\n\ntreemix -i Daruanus_treemix.txt.gz -o Tua_0m -micro -root Tuamotus -global -m 0 \ntreemix -i Daruanus_treemix.txt.gz -o Tua_1m -micro -root Tuamotus -global -m 1 \ntreemix -i Daruanus_treemix.txt.gz -o Tua_2m -micro -root Tuamotus -global -m 2 \ntreemix -i Daruanus_treemix.txt.gz -o Tua_3m -micro -root Tuamotus -global -m 3 \ntreemix -i Daruanus_treemix.txt.gz -o Tua_4m -micro -root Tuamotus -global -m 4 \ntreemix -i Daruanus_treemix.txt.gz -o Tua_5m -micro -root Tuamotus -global -m 5\n\n\n\nPlot\n\n\nCode\nsetwd(\"./treemix/5pop_explore\")\nplot_tree(\"PNG_0m\")\nplot_resid(\"PNG_0m\", \"../5poporder.txt\")\nplot_tree(\"PNG_1m\")\nplot_resid(\"PNG_1m\", \"../5poporder.txt\")\nplot_tree(\"PNG_2m\")\nplot_resid(\"PNG_2m\", \"../5poporder.txt\")\nplot_tree(\"PNG_3m\")\nplot_tree(\"PNG_4m\")\nplot_tree(\"PNG_5m\")\nplot_tree(\"PNG_6m\")\n\nplot_tree(\"PNG_2mse\")\nplot_resid(\"PNG_2mse\", \"../5poporder.txt\")\n\nplot_tree(\"Tua_0m\")\nplot_tree(\"Tua_1m\")\nplot_tree(\"Tua_2m\")\nplot_tree(\"Tua_3m\")\nplot_tree(\"Tua_4m\")\nplot_tree(\"Tua_4m\")\nplot_tree(\"Tua_5m\")"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#how-many-migration-events",
    "href": "Daruanus_IBD_migrate.html#how-many-migration-events",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "How many migration events?",
    "text": "How many migration events?\nIt turns out you can evaluate the likelihood of the Treemix model in the same way that is frequently done for structure using the Evanno, Regnaut, and Goudet (2005) method. Fitak (2021) developed the OptM package to do this, and a few other statistics as well\n\nRun Treemix at a variety of m\nRun 5 replicates of Treemix for migration edges of 1 through 10.\n\n\nCode\nfor m in {1..10}; do\n       \n  for n in {1..5}; do\n              # Generate random seed\n        s=$RANDOM\n        treemix -i ../Daruanus_treemix.txt.gz -o PNG.${n}.${m} -global -m ${m} -seed ${s} -micro\n  done\ndone\n\n\n\n\nOptM\nSo the OptM algorithm doesn’t work because the standard deviation across replicates is zero, because these are microsats, not SNPs. So I will borrow the read.treemix() function and do the analysis myself.\n\n\nCode\n#PNG <- optM(\"./\", tsv=\"PNG_root_OptM.tsv\")\n\nPNG <- OptM:::read.treemix(\"treemix/5pops_PNG\",orientagraph = F) %>% arrange(M) %>% \n        group_by(M) %>% summarize(LnPD = mean(LnPD)) %>% \n          mutate(deltaM = LnPD- lag(LnPD))\n\nPNG$deltaM[1] <- 0\n\nPNG %>% ggplot(aes(x = M, y = LnPD)) + geom_point() + scale_x_continuous(n.breaks=10)\n\n\n\n\n\nCode\nPNG %>% ggplot(aes(x = M, y = deltaM)) + geom_point() + geom_line() +\n            scale_x_continuous(n.breaks=10)\n\n\n\n\n\n\n\nPlot\n\n\nCode\nsource(\"./treemix/plotting_funcs.R\")\nplot_tree(\"./treemix/5pops_PNG/PNG.5.1\")\nplot_resid(\"./treemix/5pops_PNG/PNG.1.1\",\"./treemix/5poporder.txt\")"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#setup-1",
    "href": "Daruanus_IBD_migrate.html#setup-1",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "Setup",
    "text": "Setup\nHere’s the parmfile I set up\n\n\nCode\n################################################################################\n# Parmfile for Migrate 3.6.4 [do not remove these first TWO lines]# generated automatically on\n# Fri Feb 4 2022\nmenu=NO\nnmlength=10\ndatatype=Brownian\n\n\n\nweights=NO\nrecover=NO\nfast-likelihood=NO\ninheritance-scalars={1.00000000000000000000}\ninclude-unknown=NO\nmicro-threshold=10\npopulation-relabel={1 2 3 4}\ninfile=../Daruanus_All_8locus.mig\nrandom-seed=AUTO #OWN:410568459\ntitle= Palythoa tuberculosa - Hawaii\nprogress=YES\nlogfile=YES:logfile.txt\nprint-data=NO\noutfile=outfile.txt\npdf-outfile=outfile.pdf\npdf-terse=YES\nuse-M=YES\nprint-tree=NONE\nmig-histogram=MIGRATIONEVENTSONLY\nskyline=NO #needs mig-histogram=ALL:...\nmutation=CONSTANT\ncustom-migration={\n* * 0 0\n* * * 0\n0 * * *\n0 0 * *\n}\ngeo=NO\n\nbayes-posteriorbins= 500 500\nbayes-posteriormaxtype=TOTAL\nbayes-file=YES:bayesfile\nbayes-allfile=YES:bayesallfile\nbayes-all-posteriors=YES:bayesallposterior\nbayes-proposals= THETA METROPOLIS-HASTINGS Sampler\nbayes-proposals= MIG METROPOLIS-HASTINGS Sampler\nbayes-proposals= DIVERGENCE METROPOLIS-HASTINGS Sampler\nbayes-proposals= DIVERGENCESTD METROPOLIS-HASTINGS Sampler\nbayes-priors= THETA WEXPPRIOR: 0.0 0.001 0.1000000 0.01000 \nbayes-priors= MIG WEXPPRIOR: 0.000100 1000.000000 10000 100\nbayes-priors= RATE * * UNIFORMPRIOR: 0.000000 10000000000.000000 1000000000.000000 \nbayes-hyperpriors=NO\nlong-chains=1\nlong-inc=100\nlong-sample=10000\nburn-in=2000  \nauto-tune=YES:0.440000\nassign=NO\nheating=YES:1:{1.000000,1.500000,3.000000,5,10,1000000.000000}\nheated-swap=YES\nmoving-steps=NO\ngelman-convergence=No\nreplicate=YES:3\nend\n\n\nAnd the datafile I converted from the 8-locus genpop file with PGDSpider.\nThe header looks like\n\n4 8 . D. aruanus dataset lumped by archipelago with 3 loci removed for HWE violation - EDC 3/28/2022\n#@M 2 3 2 2 2 2 2 2"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#initial-runs",
    "href": "Daruanus_IBD_migrate.html#initial-runs",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "Initial Runs",
    "text": "Initial Runs\nCopied up to Nautilus and ran it with:\n\nscreen -S migrate_testrun\n\nmpirun -np 32 ~/migrate-4.4.4/src/migrate-n-mpi parmfile\n\n# And on Montastraea\nmpirun -np 16 ~/eric_data/migrate-3.7.2/src/migrate-n-mpi parmfile\n\n\nSymmetric Stepping StoneEast to West Stepping StoneWest to East Stepping StoneSmaller PriorsDivergence with Gene FlowDivergence without gene flow\n\n\n\ncustom-migration={\n* S 0 0\nS * S 0\n0 S * S\n0 0 S *\n}\n\n\n\n\ncustom-migration={\n* * 0 0\n0 * * 0\n0 0 * *\n0 0 0 *\n}\n\n\n\n\ncustom-migration={\n* 0 0 0\n* * 0 0\n0 * * 0\n0 0 * *\n}\n\n\n\n\nbayes-priors= THETA WEXPPRIOR: 0.0 0.01 1.000000 0.01000 \nbayes-priors= MIG WEXPPRIOR: 0.0100 100.000000 1000 10\n\nThis definitely improved things. Now all gene flow parameters are around 40! But the model marginal likelihood is all wonky.\n\n\nNow I’m going to add divergence with gene flow (going from West to East). Also change the migration priors to uniform.\n\nbayes-priors= THETA * * WEXPPRIOR: 0.0 0.01 1.000000 0.01000 \nbayes-priors= MIG * * UNIFORMPRIOR: 0 100 10\nbayes-priors= SPLIT * * UNIFORMPRIOR: 0 1000  10\nbayes-priors= SPLITSTD * * UNIFORMPRIOR: 0 500 10 \n\ncustom-migration={\n*       0       0       0\nD       *       0       0\n0       D       *       0\n0       0       D       *\n}\n\nAfter this exchange with Peter, I changed the priors to be the same as Theta.\n\nbayes-priors= THETA * * WEXPPRIOR: 0.0 0.01 1.000000 0.01000 \nbayes-priors= MIG * * UNIFORMPRIOR: 0 100 10\ndivergence-distrib = S\nbayes-priors= SPLIT * * WEXPPRIOR: 0.0 0.01 1.000000 0.01000 \nbayes-priors= SPLITSTD * * WEXPPRIOR: 0.0 0.01 1.000000 0.01000 \n\nResults look like there is little to no gene flow among archipelagos\n\n\nSo let’s look at a model of no gene flow\n\ncustom-migration={\n*       0       0       0\nd       *       0       0\n0       d       *       0\n0       0       d       *\n}"
  },
  {
    "objectID": "Daruanus_IBD_migrate.html#final-runs",
    "href": "Daruanus_IBD_migrate.html#final-runs",
    "title": "Isolation by Distance and Migration Analysis for Dascyllus aruanus",
    "section": "Final Runs",
    "text": "Final Runs\nOK, so after some futzing around with these models, I am now trying 11 models for what I hope will be a publishable analysis.\nAll built on this parmfile\n\n\nCode\n################################################################################\n# Parmfile for Migrate 3.6.4 [do not remove these first TWO lines]# generated automatically on\n# Fri Feb 4 2022\nmenu=NO\nnmlength=10\ndatatype=Brownian\nweights=NO\nrecover=NO\nfast-likelihood=NO\ninheritance-scalars={1.00000000000000000000}\ninclude-unknown=NO\nmicro-threshold=10\npopulation-relabel={1 2 3 4}\ninfile=../../Daruanus_All_8locus.mig\nrandom-seed=AUTO #OWN:410568459\ntitle= Dascyllus aruanus - South Pacific Archipelagos\nprogress=YES\nlogfile=YES:logfile.txt\nprint-data=NO\noutfile=outfile.txt\npdf-outfile=outfile.pdf\npdf-terse=YES\nuse-M=NO\nprint-tree=NONE\nmig-histogram=MIGRATIONEVENTSONLY\nskyline=NO #needs mig-histogram=ALL:...\nmutation=CONSTANT\ncustom-migration={\n* S 0 0\nS * S 0\n0 S * S\n0 0 S *\n}\ngeo=NO\nbayes-posteriorbins= 2000 2000\nbayes-posteriormaxtype=TOTAL\nbayes-file=YES:bayesfile\nbayes-allfile=YES:bayesallfile\nbayes-all-posteriors=YES:bayesallposterior\nbayes-proposals= THETA METROPOLIS-HASTINGS Sampler\nbayes-proposals= MIG METROPOLIS-HASTINGS Sampler\nbayes-proposals= SPLITSTD METROPOLIS-HASTINGS Sampler\nbayes-proposals= SPLIT METROPOLIS-HASTINGS Sampler\nbayes-priors= THETA * * WEXPPRIOR: 0.0 0.1 20.00000 0.1000 \nbayes-priors= MIG * * UNIFORMPRIOR: 0 100 10\ndivergence-distrib= E\nbayes-priors= SPLIT * * WEXPPRIOR: 0.0 0.01 1.000000 0.01000\nbayes-priors= SPLITSTD * * WEXPPRIOR: 0.0 0.01 1.000000 0.01000\nmigration=PRIOR:10\nrate=PRIOR:50\nsplit=PRIOR:10\nsplitstd=PRIOR:10\nbayes-hyperpriors=NO\nlong-chains=1\nlong-inc=100\nlong-sample=10000\nburn-in=10000  \nauto-tune=YES:0.440000\nassign=NO\nheating=YES:1:{1.000000,1.500000,3.000000,7,15,1000000.000000}\nheated-swap=YES\nmoving-steps=NO\ngelman-convergence=No\nreplicate=NO\nend\n\n\n\nModels\n\nAsymmetric Equilibrium Gene FlowSymmetric Equilibrium Gene Flown-IslandPanmixiaEast to West Divergence with Gene FlowWest to East Divergence with Gene FlowEast to West Divergence without Gene FlowWest to East Treemix\n\n\nThe “standard” stepping stone model. Gene flow at equilibrium between neighboring archipelagos\n\ncustom-migration={\n* * 0 0 0\n* * * 0 0\n0 * * * 0\n0 0 * * *\n0 0 0 * *\n}\n\n\n\nSame as above, but gene flow in either direction is symmetric for each pair of archipelagos\n\ncustom-migration={\n* S 0 0 0\nS * S 0 0\n0 S * S 0\n0 0 S * S\n0 0 0 S *\n}\n\n\nEast To West Equilibrium\nEast to West gene flow only. Following the South Equatorial current\n\ncustom-migration={\n* * 0 0 0\n0 * * 0 0\n0 0 * * 0\n0 0 0 * *\n0 0 0 0 *\n}\n\n\n\nWest to East Equilibrium\nThe other way…\n\ncustom-migration={\n* 0 0 0 0\n* * 0 0 0\n0 * * 0 0\n0 0 * * 0\n0 0 0 * *\n}\n\n\n\n\nAll populations the same size. Gene flow between all populations at the same rate\n\ncustom-migration={\nm m m m m\nm m m m m\nm m m m m\nm m m m m\nm m m m m\n}\n\n\n\n\ncustom-migration={\n*\n}\n\n\n\n\ncustom-migration={\n* D 0 0 0\n0 * D 0 0\n0 0 * D 0\n0 0 0 * D\n0 0 0 0 *\n}\n\n\n\n\ncustom-migration={\n* 0 0 0 0\nD * 0 0 0\n0 D * 0 0\n0 0 D * 0\n0 0 0 D *\n}\n\n\n\n\ncustom-migration={\n* d 0 0 0\n0 * d 0 0\n0 0 * d 0\n0 0 0 * d\n0 0 0 0 *\n}\n\n\n\nBased on the treemix result above. Migration from the Societies to New Caledonia\n\ncustom-migration={\n* 0 0 0 0\nd * 0 * 0\n0 d * 0 0\n0 0 d * 0\n0 0 0 d *\n}\n\n\n\n\n\n\nRun It\nCopy it up to Nautilus, make 10 replicate folders.\n\nscp -r ./migrate/Models2 naut:./Daruanus3/rep1\n\nfor a in $(seq 2 10); do cp -r rep1 rep$a; done\n\n\nBash Script\nSo we will do 10 replicates of 3 replicates. This will start at r1, and run all models for that before moving on. Pretty sure this will finish one whole model before moving on to the next one (since all threads are being used for different loci)\n\n\nCode\n### Bash Script\n#!\nfor r in */\n        do\n        echo starting $r at $(date )>> progress.txt\n                cd $r\n                echo $r\n                date\n                date > progress.txt\n                        for m in */\n                          do\n                          echo starting $m at $(date )>> progress.txt\n                                cd $m\n                                  date > date.txt\n                                  echo $m\n                                  date\n                                  mpirun --use-hwthread-cpus -np 120 ~/migrate-4.4.4/src/migrate-n-mpi parmfile\n                                  sleep 1\n                                cd ..\n                          done\n                cd ..\n        done\n\n\n\n\nCopy It Down\n\nrsync -av -e ssh --exclude='bayes*' --exclude=\"*.pdf\" --exclude=\"*.mig\" ecrandall@nautilus.psu.edu:~/Daruanus3/ output3\n\nrsync -av -e ssh ecrandall@nautilus.psu.edu:~/daruanus/rep1/EtoW_DivMig output/rep1/EtoW_DivMig\n\n\n\n\nResults\n\nFunction library\nStarting material for this one is from the Ptuberculosa_migrate.rmd\n\n\nCode\nharvest.model.likelihoods <- function(workingDir = workingDir,\n                   outfileName = \"outfile.txt\",\n                    multilocus = T){\n    # this function harvests model marginal likelihoods for models calculated by\n    # the program migrate-n (Beerli & Felsenstein 2001).\n    # It takes as input a directory full of directories, \n    # each of which contains output from a migrate model, and is named\n    # after that model. \n  \n    #initialize a data frame to take the values\n    modelMarglikes <- data.frame(model=character(),\n                   thermodynamic=numeric(),\n                   bezier.corrected=numeric(), \n                   harmonic=numeric()) \n    # loop through directories in the working directory, each of which is name\n    # after a different model\n  for(i in list.dirs(workingDir, full.names = F)[-1]){ #i<-\"stepping.stone\"\n      modelDir<-file.path(workingDir,i)\n      print(modelDir)\n    #scan in the outfile, separating at each newline\n      outfile<-scan(file=file.path(modelDir,outfileName),\n                    what=\"character\",sep=\"\\n\") \n    #find the line with the likelihoods on it and split on runs of spaces\n      marglikeline <- str_which(outfile,\"Scaling factor\")-1\n      marglikeline <- strsplit(outfile[marglikeline],\n               \"\\\\s+\", perl = T)[[1]][3:5]\n    #  if(length(marglikeline)==0){next}\n      marglikes <- c(i,marglikeline)\n     \n      modelMarglikes <- rbind(modelMarglikes,marglikes, deparse.level = 2)\n  }\n  names(modelMarglikes) <- c(\"model\",\"thermodynamic\",\n                             \"bezier.corrected\",\"harmonic\")\n  modelMarglikes[2:4] <- sapply(modelMarglikes[2:4], as.numeric)\n  return(modelMarglikes)\n}\n\nbfcalcs<-function(df,ml=\"bezier.corrected\"){\n  # This calculates log bayes factors on data frames output by\n  # harvest.model.likelihoods(), following Johnson and Omland (2004)\n  # You may choose the likelihood flavor with\n  # ml = \"bezier.corrected\", \"thermodynamic\" or \"harmonic\"\n  #df$thermodynamic <- as.numeric(df$thermodynamic)\n  #df$bezier.corrected <- as.numeric(df$bezier.corrected)\n  #df$harmonic <- as.numeric(df$harmonic)\n  mlcol <- df[[ml]] \n bmvalue <- mlcol[which.max(mlcol)]\n lbf <- 2*(mlcol-bmvalue)\n choice <- rank(-mlcol)\n modelprob <- exp(lbf/2)/sum(exp(lbf/2))\n dfall <- cbind(df,lbf,choice,modelprob)\n return(dfall)\n} \n\nmigrants.per.gen<-function(x){\n  #a function for creating Nm vectors out of m and Theta vectors.\n  #x<-x[[1]]\n  m<-names(x)[which(grepl(\"M_\",names(x)))] #names of m columns\n  #theta<-names(x)[which(grepl(\"Theta_\",names(x)))] #names of theta columns\n  for(n in m){\n    t<-paste(\"Theta\",strsplit(n,split=\"_\")[[1]][3],sep=\"_\")\n    x[,paste(\"Nm\",strsplit(n,split=\"_\")[[1]][2],strsplit(n,split=\"_\")[[1]][3],sep=\"_\")]<- x[,which(names(x)==n)]*x[,which(names(x)==t)] \n    #this hairy little statement makes a new column named \"Nm_X_Y\" and then fills it by multiplying the M_X_Y column by the Theta_Y column \n  }\n  return(x)\n}\n\nremove_prior <- function(densityd,prior,threshold = 1e-10, quad_prec = F){\n  # this function removes a prior from the \n  # y values of a density distributions (density).\n  # first it zeros values less than a threshold, then \n  # removes the prior, then renormalizes so the density\n  # sums to 1.\n  # can optionally use the mpfr package for very small density values.\n  require(Rmpfr)\n  densityd[which(densityd < threshold)] <- 0\n  if(quad_prec){\n    densityd <- mpfr(densityd,precBits = 128)\n    }\n  new <- (densityd/prior)/sum(densityd/prior)\n  new <- as.numeric(new)\n  return(new)\n}\n\nsum_over_loci <- function(df,parameter){\n      #this function takes a data frame of probability densities for many loci\n      # that have had the prior removed,\n      # together with with a logged prior named \"logPrior\",\n      #  as well as the name of a parameter (e.g. \"Theta_1\")\n      # and sums the densities over loci.\n      # Rmpfr package allows quadruple precision for \n      #calcs on very small numbers.\n    require(Rmpfr)\n  \n    #add a teeny-tiny amount to all values to avoid zeros\n    df2 <- df %>% mutate(across(starts_with(parameter), \n                        .fns= function(x) x + 1e-11))  %>% \n      #log all values\n            mutate(across(starts_with(c(parameter)),\n                  .fns=log)) %>% \n      # convert the df to rowwise so that rows can be summed\n      # and then sum across the row, including the prior\n          rowwise() %>% \n          mutate(sum_param_prior = \n          sum(c_across(starts_with(c(parameter,\"logPrior\"))))) %>% \n    #convert back to a regular df\n          ungroup()\n    \n    #need to convert to quadruple precision because \n    #these will exponentiate to very small numbers.\n    sum_param_prior_exp <- exp(mpfr(df2$sum_param_prior, precBits = 128))\n    # standardize by dividing by the sum of the column\n    sum_param_prior_standardized <-\n             sum_param_prior_exp/sum(sum_param_prior_exp)\n    \n\n    #drop the intermediate columns (no longer needed), change the standardized\n    # output back to double precision so that it can be incorporated into the df\n    # rename the summed column after the parameter\n      df3 <- df2 %>% select(-c(sum_param_prior)) %>%\n          mutate(summed_over_loci =\n          as.numeric(sum_param_prior_standardized)) %>% \n          rename_with(.fn = ~ paste(parameter), \n                      .cols = summed_over_loci)\n    return(df3)\n}\n\n\n\nsummarize_posterior <- function(posterior, \n                  parameter_type = c(\"Theta\",\"M\",\"Nm\",\"D\"),\n                  prior,\n                  n=16384,\n                  ...){\n  # this function takes a Migrate-n posterior \"bayesallfile\" as a dataframe\n  # as well as one of the parameter types, and the prior on that parameter\n  # as a tibble of x and y values. \n  # Currently only exponential priors supported\n  # it will create densities for each parameter of the given type,\n  # remove the prior from each, sum across loci, and re-add the prior (once)\n  parameters <- names(posterior) %>%\n                        str_subset(parameter_type)\n\n  # create a tibble with x values for a density plot\n  #  of the chosen number of points\n  dens <- prior\n  \n  print(\"calculating densities\")\n  # calculate densities for each parameter of a given type at each locus\n  dens <- posterior %>% \n          select(starts_with(c(\"StepsR\",\"Locus\",\n                  paste0(parameter_type,\"_\")))) %>% \n          pivot_wider(names_from = \"Locus\", values_from = \n                  starts_with(paste0(parameter_type,\"_\")),\n                          names_sep = \"-\") %>% \n          select(starts_with(paste0(parameter_type,\"_\"))) %>% \n          map_dfc(function(x) density(x, n = n, from = 0,\n                                    bw = \"nrd0\")$y) %>%\n          bind_cols(dens)\n  \n  # create, standardize, log and remove prior\n\n  #check for NA values\n  #df %>% \n  #select_if(function(x) any(is.na(x))) %>% \n  #summarise_each(funs(sum(is.na(.)))) -> extra_NA\n  \n  \n  print(\"removing prior\")\n  dens2 <- dens %>% \n        #remove the prior, standardize\n        mutate(across(starts_with(parameter_type), \n                  ~ remove_prior(densityd = .x,\n                                  prior = dens$prior,\n                                  threshold = 1e-10,\n                                  ...) ))\n\n  dens3 <- dens2\n    \n  for(p in parameters){\n    print(p)  \n    dens3 <- sum_over_loci(df = dens3, parameter = p)\n  }\n  # trying to do the above loop with purrr:map_dfc\n  #dens4 <- parameters %>% \n  #        map_dfc(.f = ~ sum_over_loci(df = dens2, parameter = .x))\n  return(dens3)\n}\n\nposterior_stats <- function(df,parameter){\n  require(spatstat.core)\n  p <- df %>% select(all_of(c(\"x\",parameter))) %>% as.list(bw = 1)\n  names(p) <- c(\"x\", \"y\")\n  p$bw <- 1\n  attr(p, \"class\") <- \"density\"\n  qu <- quantile.density(p, c(0.025, 0.25, 0.5, 0.75, 0.975))\n  wmo <- p$x[which(p$y==max(p$y))]\n  wme <- weighted.mean(p$x, p$y)\n  wsd <- sqrt(weighted.var(p$x, p$y))\n  stats <- c(qu,mode = wmo, mean = wme, sd = wsd)\n  return(stats)\n}\n\n\n\n\nModel Marginal Likelihoods\n\n\nCode\nrunDir <- \"./migrate/output2\"\n\nlikelist <- list()\nfor(r in 1:10){\n  rep = paste0(\"rep\",r)\n  print(rep)\n  likelist[[rep]] <- harvest.model.likelihoods(workingDir=                                             file.path(runDir,rep))\n}\n\n# Model selection for each replicate...\nlikelist %>% map(bfcalcs)\n\n\nThe final model marginal likelihood estimates based on the mean of 10 replicates. The best model is West to East divergence with migration as specified by Treemix (a single migration event from Societies to New Caledonia)!\n\n\nCode\nlike.df <-  likelist %>% bind_rows() %>% group_by(model)\n\nmeans <- like.df %>% summarize(bezier.corrected = mean(bezier.corrected))\n  \n\nfinal_model <- bfcalcs(means)\n\nfinal_model\n\n\n\n\n  \n\n\n\n\nT-Test\nDifference between West to East Treemix and the second-place East to West Treemix model is not significant, due to fairly large variability in marginal likelhoods. Need to consider this in the discussion.\n\n\nCode\ntop.choice <- final_model$model[which(final_model$choice ==1)]\nsecond.choice <- final_model$model[which(final_model$choice ==2)]\nthird.choice <- final_model$model[which(final_model$choice ==3)]\n\npermTS(like.df$bezier.corrected[which(like.df$model == top.choice)],\n       like.df$bezier.corrected[which(like.df$model == second.choice)],\n       alternative = \"greater\", method = \"exact.ce\")\n\n\n\n    Exact Permutation Test (complete enumeration)\n\ndata:  GROUP 1 and GROUP 2\np-value = 0.1183\nalternative hypothesis: true mean GROUP 1 - mean GROUP 2 is greater than 0\nsample estimates:\nmean GROUP 1 - mean GROUP 2 \n                    40019.9 \n\n\nCode\npermTS(like.df$bezier.corrected[which(like.df$model == top.choice)],\n       like.df$bezier.corrected[which(like.df$model == third.choice)],\n       alternative = \"greater\", method = \"exact.ce\")\n\n\n\n    Exact Permutation Test (complete enumeration)\n\ndata:  GROUP 1 and GROUP 2\np-value = 0.09168\nalternative hypothesis: true mean GROUP 1 - mean GROUP 2 is greater than 0\nsample estimates:\nmean GROUP 1 - mean GROUP 2 \n                    54014.3 \n\n\n\n\nModel Selection Figures\nAnd a figure summarizing all this\n\n\nCode\nmodels <- c(\"2-way Stepping-Stone Equilibrium\",\n            \"E to W Divergence with Migration\",\n            \"E to W Divergence Only\",\n            \"E to W Treemix\", \n            \"E to W Stepping-Stone Equilibrium\",\n            \"n-Island\",\n            \"Panmixia\",\n            \"W to E Divergence with Migration\",\n            \"W to E Divergence Only\",\n            \"W to E Treemix\", \n            \"W to E Stepping-Stone Equilibrium\")\n\nlikesPlot <- likelist %>% bind_rows() %>% group_by(model) %>% \n              ggplot(mapping = aes(x=model, y = bezier.corrected)) +\n              geom_violin(draw_quantiles = 0.5) +\n              theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +\n              scale_x_discrete(labels = models) +\n              labs(x = \"Metapopulation Model\", y = \"Bezier Corrected Marginal Likelihood\") +\n              theme(axis.text.x = element_text(angle = 45, vjust = 1))\nlikesPlot\n\n\n\n\n\nCode\nlikesPlot2 <- likesPlot + ylim(-4.05e7, -3.94e7)\n\nlikesPlot2\n\n\n\n\n\n\n\n\nParameter Estimates\n\nPriors\nHere are the priors I’m using for models, as a reminder.\nbayes-priors= THETA * * WEXPPRIOR: 0.0 0.1 1.000000 0.1000 \nbayes-priors= MIG * * UNIFORMPRIOR: 0 300 30\ndivergence_distrib = E\nbayes-priors= SPLIT * * WEXPPRIOR: 0.0 0.01 1.000000 0.01000\nbayes-priors= SPLITSTD * * WEXPPRIOR: 0.0 0.01 1.000000 0.01000"
  }
]